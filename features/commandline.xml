<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 74ba8fee2972b6ba4f955392d760dea54e757a95 Maintainer: PhilDaiguille Status: ready -->
<!-- Reviewed: no -->

<chapter xml:id="features.commandline" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Utilización de la línea de comandos</title>
 <titleabbrev>Utilización de líneas de comando</titleabbrev>

 <!--Introduction: {{{-->
 <section xml:id="features.commandline.introduction" annotations="chunk:false">
  <title>Introducción</title>

  <para>
   El propósito principal de &cli.sapi; es el desarrollo de aplicaciones shell con PHP. Las diferencias entre &cli.sapi; y otros <acronym>SAPI</acronym> se explican en este capítulo. Es importante mencionar que &cli; y <acronym>CGI</acronym> son <acronym>SAPI</acronym> diferentes a pesar de que puedan compartir la mayor parte de sus comportamientos.
  </para>

  <para>
   El &cli.sapi; se activa por defecto utilizando la opción <option role="configure">--enable-cli</option>, pero se puede desactivar utilizando la opción <option role="configure">--disable-cli</option> al ejecutar el comando <command>./configure</command>.
  </para>

  <para>
   El nombre, la ubicación y la existencia de los binarios &cli;/<acronym>CGI</acronym> dependerán de la forma en que PHP esté instalado en su sistema. Por defecto, al ejecutar <command>make</command>, ambos binarios <acronym>CGI</acronym> y &cli; se compilan y se nombran respectivamente <filename>sapi/cgi/php</filename> y <filename>sapi/cli/php</filename> en su directorio fuente PHP. Se observará que ambos se nombran <filename>php</filename>. Lo que sucede después durante el <command>make install</command> depende de su línea de configuración. Si un módulo <acronym>SAPI</acronym>, como apxs, se ha elegido durante la configuración, o si la opción <option role="configure"> --disable-cgi</option> se ha activado, el &cli; se copia en <filename>{PREFIX}/bin/php</filename> durante el <command>make install</command>, de lo contrario, el <acronym>CGI</acronym> se colocará aquí. Si, por ejemplo, <option role="configure">--with-apxs</option> figura en su línea de configuración, el &cli; se copia en <filename>{PREFIX}/bin/php</filename> durante el <command>make install</command>. Si se desea forzar la instalación del binario <acronym>CGI</acronym>, ejecute <command>make install-cli</command> después del <command>make install</command>. De lo contrario, también se puede especificar <option role="configure">--disable-cgi</option> en su línea de configuración.
  </para>

  <note>
   <para>
    Dado que ambas opciones <option role="configure">--enable-cli</option> y <option role="configure">--enable-cgi</option> están activadas por defecto, tener simplemente <option role="configure">--enable-cli</option> en su línea de configuración no implica necesariamente que el CLI se renombre a <filename>{PREFIX}/bin/php</filename> durante el <command>make install</command>.
   </para>
  </note>

  <para>
   El binario &cli; se distribuye en el directorio principal bajo el nombre de <filename>php.exe</filename> en Windows. La versión <acronym>CGI</acronym> se distribuye bajo el nombre de <filename>php-cgi.exe</filename>. Además, un archivo <filename>php-win.exe</filename> se distribuye si PHP se configura utilizando la opción de configuración <option role="configure">--enable-cli-win32</option>. Este archivo hace lo mismo que la versión &cli;, excepto que no muestra nada y no proporciona una consola.
  </para>

  <note>
   <title>¿Qué SAPI está instalado?</title>
   <para>
    Desde un terminal, ejecutar <command>php -v</command> indicará si <filename>php</filename> está en versión <acronym>CGI</acronym> o &cli;. También se puede consultar la función <function>php_sapi_name</function> y la constante <constant>PHP_SAPI</constant>.
   </para>
  </note>
  <note>
   <para>
    Una página <literal>man</literal> de manual Unix está disponible escribiendo <command>man php</command> en el intérprete de comandos.
   </para>
  </note>
 </section>
 <!--}}}-->

 <!--Differences: {{{-->
 <section xml:id="features.commandline.differences">
  <title>Diferencia con otros <acronym>SAPI</acronym>s</title>

  <para>
   Las diferencias más notables entre el &cli; <acronym>SAPI</acronym> y los otros <acronym>SAPI</acronym> son:
   <itemizedlist>
    <listitem>
     <para>
      A diferencia del <acronym>CGI</acronym> <acronym>SAPI</acronym>, ningún encabezado HTTP se escribe en el resultado.
     </para>
     <para>
      Aunque el <acronym>CGI</acronym> <acronym>SAPI</acronym> proporciona una forma de eliminar los encabezados HTTP, no es posible activar los encabezados HTTP en el &cli.sapi;.
     </para>
     <para>
      &cli; se ejecuta en modo silencioso por defecto, aunque las opciones <option>-q</option> y <option>--no-header</option> se mantienen para mantener la compatibilidad con versiones anteriores de <acronym>CGI</acronym>.
     </para>
     <para>
      No cambia el directorio actual al del script. (Las opciones <option>-C</option> y <option>--no-chdir</option> se mantienen por razones de compatibilidad).
     </para>
     <para>
      Mensajes de error en texto plano (sin formato <acronym>HTML</acronym>).
     </para>
    </listitem>
    <listitem>
     <para>
      Hay varias directivas del &php.ini; que son ignoradas por el &cli.sapi;, ya que no tienen sentido en un entorno shell:
     </para>
     <para>
      <table>
       <title>Directivas &php.ini; ignoradas</title>
       <tgroup cols="3">
        <thead>
         <row>
          <entry>Directiva</entry>
          <entry>Valor por defecto para &cli; <acronym>SAPI</acronym></entry>
          <entry>Comentario</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><link linkend="ini.html-errors"><option>html_errors</option></link></entry>
          <entry>&false;</entry>
          <entry>
           Por defecto a &false;, ya que puede ser bastante difícil leer mensajes de error en un terminal cuando están enterrados en etiquetas <acronym>HTML</acronym> no interpretadas.
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.implicit-flush"><option>implicit_flush</option></link></entry>
          <entry>&true;</entry>
          <entry>
           En un terminal, generalmente es deseable que cualquier salida de <function>print</function>, <function>echo</function> y otros, se muestre inmediatamente, y no se coloque en un búfer. Sin embargo, siempre es posible utilizar <link linkend="ref.outcontrol">la bufferización de salida</link> si se desea retrasar una salida, o bien manipular su contenido una última vez.
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
          <entry>0 (sin límite)</entry>
          <entry>
           PHP en un terminal es susceptible de ser utilizado para tareas mucho más diversas que en scripts web, y dado que esto generalmente toma mucho tiempo, este parámetro se establecerá por defecto a 0 permitiendo así ser ilimitado.
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
          <entry>&true;</entry>
          <entry>
           <para>
            El establecimiento de esta directiva a &true; significa que los scripts ejecutados a través del <acronym>SAPI</acronym> &cli; siempre tendrán acceso a <emphasis>argc</emphasis> (representando el número de argumentos pasados a la aplicación) y <emphasis>argv</emphasis> (el array que contiene los argumentos pasados).
           </para>
           <para>
            Las variables PHP <varname>$argc</varname> y <varname>$argv</varname> se definen y rellenan automáticamente con los valores apropiados, al utilizar el <acronym>SAPI</acronym> &cli;. Estos valores también pueden encontrarse en la variable <varname>$_SERVER</varname>, por ejemplo: <varname>$_SERVER['argv']</varname>.
           </para>
           <warning>
           <para>
            La presencia de <varname>$argv</varname> o <varname>$_SERVER['argv']</varname> no es una indicación fiable de que un script se está ejecutando desde la línea de comandos, ya que estas variables pueden definirse en otros contextos cuando <link linkend="ini.register-argc-argv">register_argc_argv</link> está activado. El valor devuelto por <function>php_sapi_name</function> debe verificarse en su lugar.
            <informalexample>
             <programlisting role="php">
<![CDATA[
<?php

if (php_sapi_name() === 'cli') {
    echo "¡Este script se está ejecutando desde la línea de comandos!\n";
}
]]>
             </programlisting>
            </informalexample>
           </para>
          </warning>
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.output-buffering">output_buffering</link></entry>
          <entry>&false;</entry>
          <entry>
           <para>
            Aunque esta configuración INI está codificada a &false;, las funciones relacionadas con <link linkend="book.outcontrol">la visualización del búfer</link> están disponibles.
           </para>
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.max-input-time">max_input_time</link></entry>
          <entry>&false;</entry>
          <entry>
           <para>
            El PHP &cli; no soporta GET, POST y la carga de archivos.
           </para>
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </para>
     <note>
      <para>
       Estas directivas no pueden inicializarse con otros valores en el archivo &php.ini; o por cualquier otro método. Es una limitación, ya que estos valores por defecto se aplican una vez que todos los otros archivos de configuración han sido analizados. Sin embargo, estos valores pueden modificarse durante la ejecución (lo cual no es lógico para ciertas directivas, como <link linkend="ini.register-argc-argv">register_argc_argv</link>).
      </para>
     </note>
     <note>
      <para>
       Se recomienda establecer <link linkend="ini.ignore-user-abort">ignore_user_abort</link> para los scripts en línea de comandos. Consulte la función <function>ignore_user_abort</function> para más información.
      </para>
     </note>
    </listitem>

    <listitem>
     <para>
      Para facilitar el trabajo en un entorno shell, se definen varias constantes para los <link linkend="features.commandline.io-streams">flujos I/O</link>.
     </para>
    </listitem>

    <listitem>
     <para>
      El &cli.sapi; <emphasis role="strong">no transforma</emphasis> el directorio actual en el directorio de ejecución del script.
     </para>
     <example>
      <title>
       Ejemplo que muestra la diferencia con el <acronym>SAPI</acronym> <acronym>CGI</acronym>:
      </title>
      <programlisting role="php">
<![CDATA[
<?php
// Una prueba simple: muestra el directorio de ejecución */
echo getcwd(), "\n";
?>
]]>
      </programlisting>
      <para>
       Cuando se utiliza la versión <acronym>CGI</acronym>, la salida será:
      </para>
      <screen>
<![CDATA[
$ pwd
/tmp

$ php -q otro_directorio/test.php
/tmp/otro_directorio
]]>
      </screen>
      <para>
       Esto muestra claramente que PHP cambia el directorio actual y utiliza el directorio del script ejecutado.
      </para>
      <para>
       Al utilizar el &cli.sapi;, se obtiene:
      </para>
      <screen>
<![CDATA[
$ pwd
/tmp

$ php -f otro_directorio/test.php
/tmp
]]>
      </screen>
      <para>
       Esto proporciona mucha más flexibilidad al escribir scripts shell con PHP.
      </para>
     </example>
     <note>
      <para>
       El <acronym>CGI</acronym> <acronym>SAPI</acronym> se comporta de la misma manera que el &cli.sapi;, pasándole la opción <option>-C</option>, cuando se invoca en la línea de comandos.
      </para>
     </note>
    </listitem>
   </itemizedlist>
  </para>
 </section>
 <!--}}}-->

 <!--Options: {{{-->
 <section xml:id="features.commandline.options">
  <title>Opciones de línea de comandos</title>
  <titleabbrev>Opciones</titleabbrev>

  <para>
   La lista de opciones de línea de comandos proporcionadas por PHP está disponible en cualquier momento ejecutando PHP con la opción <option>-h</option>:
   <screen>
<![CDATA[
Uso: php [opciones] [-f] <archivo> [--] [args...]
   php [opciones] -r <código> [--] [args...]
   php [opciones] [-B <begin_code>] -R <código> [-E <end_code>] [--] [args...]
   php [opciones] [-B <begin_code>] -F <archivo> [-E <end_code>] [--] [args...]
   php [opciones] -- [args...]
   php [opciones] -a

  -a               Ejecutar de forma interactiva
  -c <ruta>|<archivo> Buscar el archivo php.ini en este directorio
  -n               No se utilizará ningún archivo php.ini
  -d foo[=bar]     Definir la entrada INI foo con el valor 'bar'
  -e               Generar información extendida para el depurador/perfilador
  -f <archivo>     Analizar y ejecutar <archivo>.
  -h               Esta ayuda
  -i               Información de PHP
  -l               Verificación de sintaxis únicamente (lint)
  -m               Mostrar módulos compilados
  -r <código>      Ejecutar el código PHP sin usar etiquetas de script <?..?>
  -B <begin_code>  Ejecutar <begin_code> antes de procesar las líneas de entrada
  -R <código>      Ejecutar el código PHP para cada línea de entrada
  -F <archivo>     Analizar y ejecutar <archivo> para cada línea de entrada
  -E <end_code>    Ejecutar <end_code> después de procesar todas las líneas de entrada
  -H               Ocultar cualquier argumento pasado de herramientas externas.
  -S <dirección>:<puerto> Ejecutar con el servidor web integrado.
  -t <docroot>     Especificar el directorio raíz del documento para el servidor web integrado.
  -s               Salida de sintaxis HTML resaltada.
  -v               Número de versión
  -w               Salida de código fuente con comentarios y espacios en blanco eliminados.
  -z <archivo>     Cargar la extensión Zend <archivo>.

  args...          Argumentos pasados al script. Usar -- args cuando el primer argumento
                   comienza con - o el script se lee desde stdin

  --ini            Mostrar nombres de archivos de configuración

  --rf <nombre>     Mostrar información sobre la función <nombre>.
  --rc <nombre>     Mostrar información sobre la clase <nombre>.
  --re <nombre>     Mostrar información sobre la extensión <nombre>.
  --rz <nombre>     Mostrar información sobre la extensión Zend <nombre>.
  --ri <nombre>     Mostrar configuración para la extensión <nombre>.
]]>
   </screen>
  </para>

  <para>
   <table>
    <title>Opciones de línea de comandos</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Opción</entry>
       <entry>Opción larga</entry>
       <entry>Descripción</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-a</entry>
       <entry>--interactive</entry>
       <entry>
        <para>
         Lanza PHP de forma interactiva. Para más información, consulte la documentación sobre el <link linkend="features.commandline.interactive">shell interactivo</link>.
        </para>
       </entry>
      </row>
      <row>
       <entry>-b</entry>
       <entry>--bindpath</entry>
       <entry>
        <para>
         Enlaza la ruta para los externos, en modo servidor FASTCGI (solo <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-C</entry>
       <entry>--no-chdir</entry>
       <entry>
        <para>
         No ir al directorio del script (solo <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-q</entry>
       <entry>--no-header</entry>
       <entry>
        <para>
         Modo silencioso. Suprime la salida de los encabezados <acronym>HTTP</acronym> (solo <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-T</entry>
       <entry>--timing</entry>
       <entry>
        <para>
         Mide el tiempo de ejecución del script, repetido <varname>count</varname> veces (solo <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-c</entry>
       <entry>--php-ini</entry>
       <entry>
        <para>
         Especifica el nombre del directorio en el que se encuentra el archivo &php.ini;, o bien especifica un archivo de configuración (<literal>INI</literal>) directamente (que no se llama necesariamente &php.ini;):
        </para>
        <para>
         <informalexample>
          <screen>
<![CDATA[
$ php -c /custom/directory/ mon_script.php

$ php -c /custom/directory/custom-file.ini mon_script.php
]]>
          </screen>
         </informalexample>
        </para>
        <para>
         Si esta opción no se especifica, &php.ini; se buscará en los <link linkend="configuration.file">lugares por defecto</link>.
        </para>
       </entry>
      </row>
      <row>
       <entry>-n</entry>
       <entry>--no-php-ini</entry>
       <entry>
        <para>
         Ignora completamente &php.ini;.
        </para>
       </entry>
      </row>
      <row>
       <entry>-d</entry>
       <entry>--define</entry>
       <entry>
        <para>
         Define un valor personalizado para cualquier directiva de configuración del archivo &php.ini;. La sintaxis es:
         <screen>
<![CDATA[
 -d configuration_directive[=value]
]]>
         </screen>
        </para>
        <para>
         <example>
          <title>Ejemplo de uso de <literal>-d</literal> para establecer una configuración INI</title>
          <screen>
<![CDATA[
# La omisión del valor conduce a dar el valor de "1"
$ php -d max_execution_time
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# Pasar un valor vacío conduce a dar el valor de ""
php -d max_execution_time=
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# La directiva de configuración será cualquier valor pasado después del carácter '='
$  php -d max_execution_time=20
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php
        -d max_execution_time=doesntmakesense
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
          </screen>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>-e</entry>
       <entry>--profile-info</entry>
       <entry>
        <para>
         Genera información extendida para la depuración y el perfilado.
        </para>
       </entry>
      </row>
      <row>
       <entry>-f</entry>
       <entry>--file</entry>
       <entry>
        <para>
         Analiza y ejecuta el archivo especificado. La opción <option>-f</option> es opcional y puede omitirse. El nombre del archivo es suficiente.
        </para>
       </entry>
      </row>
      <row>
       <entry>-h y -?</entry>
       <entry>--help y --usage</entry>
       <entry>
        Muestra información sobre la lista actual de opciones de la línea de comandos, así como su descripción.
       </entry>
      </row>
      <row>
       <entry>-i</entry>
       <entry>--info</entry>
       <entry>
        Llama a la función <function>phpinfo</function> y muestra el resultado. Si PHP no funciona correctamente, se recomienda utilizar el comando <command>php -i</command> y ver si no hay errores mostrados antes o después de la tabla de información. No olvide que el resultado de esta opción, si se utiliza el modo <acronym>CGI</acronym>, está en formato <acronym>HTML</acronym> y, por lo tanto, es de tamaño considerable.
       </entry>
      </row>
      <row>
       <entry>-l</entry>
       <entry>--syntax-check</entry>
       <entry>
        <para>
         Verifica la sintaxis pero no ejecuta el código PHP dado. La entrada proveniente de la entrada estándar se procesará si no se especifica ningún nombre de archivo, de lo contrario, cada archivo especificado se verificará. En caso de éxito, se muestra el mensaje <literal>No syntax errors detected in &lt;filename&gt;</literal> (Literalmente, no se detectaron errores de sintaxis en el archivo) en la salida estándar. En caso de error, se muestra el mensaje <literal>Errors parsing &lt;filename&gt;</literal> (Literalmente, error de análisis en el archivo filename) junto con los mensajes de error detectados por el analizador mismo. Si se encuentran errores en los archivos especificados (o en la entrada estándar), el código de retorno del shell se establece en <literal>-1</literal>, de lo contrario, el código de retorno del shell se establece en <literal>0</literal>.
        </para>
        <para>
         Esta opción no detecta errores fatales (por ejemplo, funciones no definidas) que requieren la ejecución del código.
        </para>
        <note>
         <para>
          Antes de PHP 8.3.0, solo se podía especificar un nombre de archivo para verificar.
         </para>
        </note>
        <note>
         <para>
          Esta opción no funciona con la opción <option>-r</option>.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-m</entry>
       <entry>--modules</entry>
       <entry>
        <para>
         <example>
          <title>Mostrar módulos internos (y cargados) de PHP y Zend</title>
          <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
          </screen>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>-r</entry>
       <entry>--run</entry>
       <entry>
        <para>
         Permite la ejecución de PHP directamente en la línea de comandos. Las etiquetas de PHP (<literal>&lt;?php</literal> y <literal>?&gt;</literal>) <emphasis role="strong">no son</emphasis> necesarias y causarán un error de análisis si están presentes.
        </para>
        <note>
         <para>
          Se debe prestar especial atención al utilizar esta opción de PHP para que no haya colisión con las sustituciones de variables en la línea de comandos realizadas por el shell.
         </para>
         <example>
          <title>Error de sintaxis al usar comillas dobles</title>
          <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
PHP Parse error:  syntax error, unexpected '=' in Command line code on line 1

Parse error: syntax error, unexpected '=' in Command line code on line 1
]]>
          </screen>
         </example>
         <para>
          El problema aquí es que el shell (sh/bash) realiza una sustitución de variables, incluso con las comillas dobles <literal>"</literal>. Dado que la variable <varname>$foo</varname> probablemente no está definida en el shell, se reemplaza por nada, lo que hace que el código pasado a PHP para ejecutar sea:
         </para>
         <informalexample>
          <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
          </screen>
         </informalexample>
         <para>
          La solución a este problema es utilizar comillas simples <literal>'</literal>. Las variables de estas cadenas no serán sustituidas por sus valores por el shell.
         </para>
         <example>
          <title>Uso de comillas simples para evitar una sustitución por el shell</title>
          <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
          </screen>
         </example>
         <para>
          Si se utiliza un shell diferente de sh/bash, pueden encontrarse otros problemas; si es apropiado, se puede abrir un informe de errores a través de <link xlink:href="&url.php.bugs;">&url.php.bugs;</link>. Es muy fácil tener problemas al intentar incluir variables de shell en el código, o al usar las barras invertidas para la protección. ¡Se le ha advertido!
         </para>
        </note>
        <note>
         <para>
          <option>-r</option> está disponible con el &cli.sapi; pero no con el <acronym>SAPI</acronym> <emphasis>CGI</emphasis>.
         </para>
        </note>
        <note>
         <para>
          Esta opción solo se utiliza para cosas simples. Por lo tanto, algunas directivas de configuración (por ejemplo, <link linkend="ini.auto-prepend-file">auto_prepend_file</link> y <link linkend="ini.auto-append-file">auto_append_file</link>) se ignoran en este modo.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-B</entry>
       <entry>--process-begin</entry>
       <entry>
        <para>
         Código PHP a ejecutar antes de procesar stdin.
        </para>
       </entry>
      </row>
      <row>
       <entry>-R</entry>
       <entry>--process-code</entry>
       <entry>
        <para>
         Código PHP a ejecutar para cada línea de entrada.
        </para>
        <para>
         Hay dos variables especiales disponibles en este modo: <varname>$argn</varname> y <varname>$argi</varname>. <varname>$argn</varname> debe contener la línea PHP procesada en ese momento, mientras que <varname>$argi</varname> debe contener el número de la línea.
        </para>
       </entry>
      </row>
      <row>
       <entry>-F</entry>
       <entry>--process-file</entry>
       <entry>
        <para>
         Archivo PHP a ejecutar para cada línea de entrada.
        </para>
       </entry>
      </row>
      <row>
       <entry>-E</entry>
       <entry>--process-end</entry>
       <entry>
        <para>
         Código PHP a ejecutar después de realizar la entrada.
        </para>
        <para>
         <example>
          <title>Ejemplo de uso de las opciones <option>-B</option>, <option>-R</option> y <option>-E</option> para contar el número de líneas de un proyecto.</title>
          <screen>
<![CDATA[
$ find my_proj | php -B '$l=0;' -R '$l += count(@file($argn));' -E 'echo "Total Lines: $l\n";'
Total Lines: 37328
]]>
          </screen>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>-S</entry>
       <entry>--server</entry>
       <entry>
        <para>
         Inicia el <link linkend="features.commandline.webserver">servidor web interno</link>. Disponible desde 5.4.0.
        </para>
       </entry>
      </row>
      <row>
       <entry>-t</entry>
       <entry>--docroot</entry>
       <entry>
        Especifica la raíz de los documentos para el <link linkend="features.commandline.webserver">servidor web interno</link>.
       </entry>
      </row>
      <row>
       <entry>-s</entry>
       <entry>--syntax-highlight y --syntax-highlighting</entry>
       <entry>
        <para>
         Muestra el código con colorización de sintaxis.
        </para>
        <para>
         Esta opción utiliza el mecanismo interno para analizar el archivo y escribir una versión coloreada del código fuente en formato HTML. Tenga en cuenta que esta opción solo genera un bloque HTML, con las etiquetas HTML <literal>&lt;code&gt; [...] &lt;/code&gt;</literal>, sin encabezados HTML.
        </para>
        <note>
         <para>
          Esta opción no funciona con la opción <option>-r</option>.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-v</entry>
       <entry>--version</entry>
       <entry>
        <para><example>
         <title>Uso de la opción <option>-v</option> para recuperar el nombre del <acronym>SAPI</acronym> así como la versión de PHP y de Zend</title>
         <screen>
<![CDATA[
$ php -v
PHP 5.3.1 (cli) (built: Dec 11 2009 19:55:07)
Copyright (c) 1997-2009 The PHP Group
Zend Engine v2.3.0, Copyright (c) 1998-2009 Zend Technologies
]]>
         </screen>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>-w</entry>
       <entry>--strip</entry>
       <entry>
        <para>
         Muestra el código fuente sin comentarios ni espacios.
        </para>
        <note>
         <para>
          Esta opción no funciona con la opción <option>-r</option>.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-z</entry>
       <entry>--zend-extension</entry>
       <entry>
        <para>
         Carga una extensión Zend. Si y solo si se proporciona un archivo, PHP intentará cargar esta extensión en el directorio predeterminado de las bibliotecas en su sistema (generalmente especificado con <filename>/etc/ld.so.conf</filename> en Linux, por ejemplo). Pasar un nombre de archivo con la ruta completa hará que PHP use este archivo, sin buscar en los directorios habituales. Una ruta de directorio relativa, que incluya información sobre el directorio, indicará a PHP que debe buscar las extensiones solo en ese directorio.
        </para>
       </entry>
      </row>
      <row>
       <entry></entry>
       <entry>--ini</entry>
       <entry>
        <para>
         Muestra los nombres de los archivos de configuración y los directorios analizados.
         <example>
          <title>Ejemplo con <literal>--ini</literal></title>
          <programlisting role="shell">
<![CDATA[
$ php --ini
Configuration File (php.ini) Path: /usr/dev/php/5.2/lib
Loaded Configuration File:         /usr/dev/php/5.2/lib/php.ini
Scan for additional .ini files in: (none)
Additional .ini files parsed:      (none)
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--rf</entry>
       <entry>--rfunction</entry>
       <entry>
        <para>
         Muestra información sobre la función dada o el método de una clase (es decir, número y nombre de los parámetros).
        </para>
        <para>
         Esta opción solo está disponible si PHP se ha compilado con soporte <link linkend="book.reflection">Reflection</link>.
        </para>
        <para>
         <example>
          <title>Ejemplo con <literal>--rf</literal></title>
          <programlisting role="shell">
<![CDATA[
$ php --rf var_dump
Function [ <internal> public function var_dump ] {

  - Parameters [2] {
    Parameter #0 [ <required> $var ]
    Parameter #1 [ <optional> $... ]
  }
}
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--rc</entry>
       <entry>--rclass</entry>
       <entry>
        <para>
         Muestra información sobre la clase dada (lista de constantes, propiedades y métodos).
        </para>
        <para>
         Esta opción solo está disponible si PHP se ha compilado con soporte <link linkend="book.reflection">Reflection</link>.
        </para>
        <para>
         <example>
          <title>Ejemplo con <literal>--rc</literal></title>
          <programlisting role="shell">
<![CDATA[
$ php --rc Directory
Class [ <internal:standard> class Directory ] {

  - Constants [0] {
  }

  - Static properties [0] {
  }

  - Static methods [0] {
  }

  - Properties [0] {
  }

  - Methods [3] {
    Method [ <internal> public method close ] {
    }

    Method [ <internal> public method rewind ] {
    }

    Method [ <internal> public method read ] {
    }
  }
}
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--re</entry>
       <entry>--rextension</entry>
       <entry>
        <para>
         Muestra la información sobre la extensión dada (lista las opciones del &php.ini;, las funciones definidas, las constantes y las clases).
        </para>
        <para>
         Esta opción solo está disponible si PHP se ha compilado con soporte <link linkend="book.reflection">Reflection</link>.
        </para>
        <para>
         <example>
          <title>Ejemplo con <literal>--re</literal></title>
          <programlisting role="shell">
<![CDATA[
$ php --re json
Extension [ <persistent> extension #19 json version 1.2.1 ] {

  - Functions {
    Function [ <internal> function json_encode ] {
    }
    Function [ <internal> function json_decode ] {
    }
  }
}
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--rz</entry>
       <entry>--rzendextension</entry>
       <entry>
        <para>
         Muestra la información de configuración para la extensión Zend proporcionada (la misma información que la devuelta por la función <function>phpinfo</function>).
        </para>
       </entry>
      </row>
      <row>
       <entry>--ri</entry>
       <entry>--rextinfo</entry>
       <entry>
        <para>
         Muestra la información de configuración para la extensión dada (la misma información devuelta por la función <function>phpinfo</function>). Las informaciones de configuración internas están disponibles utilizando el nombre de extensión "main" o "core".
        </para>
        <para>
         <example>
          <title>Ejemplo con <literal>--ri</literal></title>
          <programlisting role="shell">
<![CDATA[
$ php --ri date

date

date/time support => enabled
"Olson" Timezone Database Version => 2009.20
Timezone Database => internal
Default timezone => Europe/Oslo

Directive => Local Value => Master Value
date.timezone => Europe/Oslo => Europe/Oslo
date.default_latitude => 59.930972 => 59.930972
date.default_longitude => 10.776699 => 10.776699
date.sunset_zenith => 90.583333 => 90.583333
date.sunrise_zenith => 90.583333 => 90.583333
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  <note>
   <para>
    Las opciones <literal>-rBRFEH</literal>, <literal>--ini</literal> y <literal>--r[fcezi]</literal> solo están disponibles en modo &cli;.
   </para>
  </note>
 </section>
 <!--}}}-->

 <!--Usage: {{{-->
 <section xml:id="features.commandline.usage">
  <title>Ejecución de archivos PHP</title>
  <titleabbrev>Utilización</titleabbrev>
  <para>
   Hay 3 formas diferentes de llamar al &cli.sapi; con código PHP a ejecutar:
   <orderedlist>
    <listitem>
     <para>
      Indicar a PHP que ejecute un archivo dado:
     </para>
     <informalexample>
      <screen>
<![CDATA[
php mon_script.php

php -f mon_script.php
]]>
      </screen>
     </informalexample>
     <para>
      Ambos métodos (usando <option>-f</option> o no) ejecutan el script contenido en el archivo <filename>mon_script.php</filename>. Tenga en cuenta que no existe restricción sobre los archivos que se pueden ejecutar; en particular, no es necesario que la extensión del archivo sea <literal>.php</literal>.
     </para>
    </listitem>
    <listitem>
     <para>
      Dar código PHP a ejecutar directamente en la línea de comandos.
     </para>
     <informalexample>
      <screen>
<![CDATA[
php -r 'print_r(get_defined_constants());'
]]>
      </screen>
     </informalexample>
     <para>
      En este caso, se debe prestar especial atención a las variables de entorno, que serán reemplazadas, y a las comillas, que tienen significados especiales en la línea de comandos.
     </para>
     <note>
      <para>
       Lea el ejemplo con atención, ¡no hay etiquetas de apertura ni de cierre! La opción <option>-r</option> hace que el uso de estas etiquetas sea innecesario, y agregarlas conduciría a un error de análisis sintáctico.
      </para>
     </note>
    </listitem>
    <listitem>
     <para>
      Alimentar la entrada estándar con código PHP (<literal>stdin</literal>).
     </para>
     <para>
      Esto proporciona la posibilidad de crear código PHP dinámicamente, luego proporcionarlo a PHP y, finalmente, procesarlo nuevamente en el shell. Aquí hay un ejemplo ficticio:
     </para>
     <informalexample>
      <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u > final_output.txt
]]>
      </screen>
     </informalexample>
    </listitem>
   </orderedlist>
   No es posible combinar estos tres modos de ejecución.
  </para>

  <para>
   Como cualquier aplicación shell, el ejecutable PHP acepta argumentos; sin embargo, el script PHP también puede recibirlos. El número de argumentos que se pueden pasar a su script no está limitado por PHP (el shell tiene un límite en términos de número de caracteres que se pueden pasar. Generalmente, no alcanzará este límite). Los argumentos pasados al script se transmitirán a través de la variable array <varname>$argv</varname>. El primer índice (cero) contiene siempre el nombre del script llamado desde la línea de comandos. Tenga en cuenta que, si el código se ejecuta en línea usando la opción de línea de comandos <option>-r</option>, el valor de <varname>$argv[0]</varname> será <literal>"Standard input code"</literal>; anterior a PHP 7.2.0, era un guion (<literal>"-"</literal>) en su lugar. Esto también es cierto si el código se ejecuta a través de un pipe desde <constant>STDIN</constant>.
  </para>

  <para>
   Una segunda variable global, <varname>$argc</varname>, contiene el número de elementos del array <varname>$argv</varname> (<emphasis role="strong">y no</emphasis> el número de argumentos pasados a su script).
  </para>

  <para>
   Mientras los argumentos pasados al script no comiencen con el carácter <literal>-</literal>, no hay nada especial que vigilar. El hecho de pasar argumentos al script que comienzan con <literal>-</literal> plantea problemas porque PHP pensará que debe interpretarlos. Para evitar esto, use el separador <literal>--</literal>. Después de este argumento, todos los argumentos siguientes se pasarán al script sin ser modificados ni analizados por PHP.
  </para>
  <informalexample>
   <screen>
<![CDATA[
# Esto no ejecutará el código, sino que mostrará la ayuda de PHP
$ php -r 'var_dump($argv);' -h
Uso: php [opciones] [-f] <archivo> [args...]
[...]

# Esto pasará el argumento '-h' al script y evitará que PHP lo maneje
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
   </screen>
  </informalexample>
  <para>
   Sin embargo, hay otra forma de usar PHP como script shell; la primera línea del script debe ser <literal>#!/usr/bin/php</literal> (a reemplazar por la ruta hacia el binario PHP &cli; en el sistema subyacente). El resto del archivo debe contener el código PHP normal, comprendido entre las etiquetas de apertura/cierre. Después de establecer los permisos de ejecución en el script (<command>chmod +x test</command>), puede ejecutarse como un script shell o perl habitual:
  </para>

  <example>
   <title>Ejecuta un script PHP como script shell</title>
   <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
var_dump($argv);
?>
]]>
   </programlisting>
   <para>
    Suponiendo que este archivo se llame <filename>test</filename>, en el directorio actual, entonces es posible hacer esto:
   </para>
   <screen>
<![CDATA[
$ chmod +x test
$ ./test -h -- foo
array(4) {
   [0]=>
   string(6) "./test"
   [1]=>
   string(2) "-h"
   [2]=>
   string(2) "--"
   [3]=>
   string(3) "foo"
}
]]>
   </screen>
  </example>

  <para>
   Como puede ver, en este caso, no es necesario tener cuidado al pasar parámetros que comienzan con <literal>-</literal> a su script.
  </para>

  <para>
   El ejecutable PHP puede ser utilizado para ejecutar scripts independientes del servidor web. Si está en un sistema Unix, se recomienda agregar la línea especial al inicio del script, hacerlo ejecutable de manera que el sistema sepa qué programa debe ejecutar el script. En Windows, puede asociar el ejecutable <filename>php.exe</filename> con el doble clic en los archivos de extensión <literal>.php</literal>, o bien puede hacer un archivo batch para ejecutar el script gracias a PHP. La primera línea utilizada en el mundo Unix no perturbará la ejecución en Windows, lo que hace que los scripts sean fácilmente portables. Un ejemplo completo se proporciona a continuación:
  </para>
  <para>
   <example>
    <title>Script previsto para ser ejecutado en línea de comandos (script.php)</title>
    <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

Esto es una línea de comando a una opción.

  Uso:
  <?php echo $argv[0]; ?> <opción>

  <opción> puede ser una palabra que desee mostrar.
  Con las opciones --help, -help, -h,
  y -?, obtendrá esta ayuda.

<?php
} else {
    echo $argv[1];
}
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   El script anterior incluye la primera línea especial que indica que este archivo debe ser ejecutado por PHP. Se trabaja aquí con la versión &cli;, por lo que no se mostrará ningún encabezado <acronym>HTTP</acronym>.
  </para>

  <para>
   El programa comienza verificando que se haya especificado el argumento requerido (además del nombre del script, que también se cuenta). Si no está presente, o si el argumento es <option>--help</option>, <option>-help</option>, <option>-h</option> o <option>-?</option>, se mostrará un mensaje de ayuda, utilizando <varname>$argv[0]</varname> para mostrar dinámicamente el nombre del script tal como se ingresó en la línea de comandos. De lo contrario, el argumento se mostrará tal como se ingresó en el terminal.
  </para>

  <para>
   Para ejecutar el script anterior en Unix, debe hacerlo ejecutable y luego llamarlo con un comando como: <command>script.php echothis</command> o <command>script.php -h</command>. En Windows, puede hacer un archivo batch para esto:
  </para>

  <para>
   <example>
    <title>Archivo batch para ejecutar un script PHP en línea de comandos (script.bat)</title>
    <programlisting role="winbat">
<![CDATA[
@echo OFF
"C:\php\php.exe" script.php %*
]]>
    </programlisting>
   </example>
  </para>

  <para>
   Suponiendo que el programa anterior se llame <filename>script.php</filename>, y que el ejecutable &cli; <filename>php.exe</filename> se encuentre en <filename>C:\php\php.exe</filename>, este archivo batch lo ejecutará con las opciones que le pase: <command>script.bat echothis</command> o <command>script.bat -h</command>.
  </para>

  <para>
   Vea también la extensión <link linkend="ref.readline">Readline</link>, que dispone de numerosas funciones para mejorar la usabilidad de las aplicaciones PHP en línea de comandos.
  </para>

  <para>
   En Windows, PHP puede configurarse para funcionar sin necesidad de proporcionar las extensiones <filename>C:\php\php.exe</filename> o <literal>.php</literal>, tal como se describe en <link linkend="install.windows.commandline">la línea de comandos PHP bajo Microsoft Windows</link>.
  </para>

  <note>
   <para>
    En Windows, se recomienda ejecutar PHP bajo una cuenta de usuario. Cuando PHP se ejecuta bajo un servicio de red, algunas operaciones pueden fallar, ya que "No se realiza ninguna vinculación entre los nombres de cuenta y los identificadores de seguridad".
   </para>
  </note>

 </section>
 <!--}}}-->

 <!--I/O Streams: {{{-->
 <section xml:id="features.commandline.io-streams">
  <title>Flujos de entrada/salida</title>
  <titleabbrev>Flujos I/O</titleabbrev>

  <para>
   El &cli.sapi; define algunas constantes para los flujos I/O para hacer que la programación en línea de comandos sea más fácil.
  </para>

  <para>
   <table>
    <title>Constantes específicas CLI</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Constante</entry>
       <entry>Descripción</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><constant>STDIN</constant></entry>
       <entry>
        <para>
         Un flujo ya abierto hacia <literal>stdin</literal>. Esto evita abrirlo explícitamente con
         <programlisting role="php">
<![CDATA[
<?php
$stdin = fopen('php://stdin', 'r');
?>
]]>
         </programlisting>
         Si desea leer una sola línea desde <literal>stdin</literal>, puede usar
         <programlisting role="php">
<![CDATA[
<?php
$line = trim(fgets(STDIN)); // lee una línea desde STDIN
fscanf(STDIN, "%d\n", $number); // lee números desde STDIN
?>
]]>
         </programlisting>
        </para>
       </entry>
      </row>
      <row>
       <entry><constant>STDOUT</constant></entry>
       <entry>
        <para>
         Un flujo ya abierto hacia <literal>stdout</literal>. Esto evita abrirlo explícitamente con
         <programlisting role="php">
<![CDATA[
<?php
$stdout = fopen('php://stdout', 'w');
?>
]]>
         </programlisting>
        </para>
       </entry>
      </row>
      <row>
       <entry><constant>STDERR</constant></entry>
       <entry>
        <para>
         Un flujo ya abierto hacia <literal>stderr</literal>. Esto evita abrirlo explícitamente con
         <programlisting role="php">
<![CDATA[
<?php
$stderr = fopen('php://stderr', 'w');
?>
]]>
         </programlisting>
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  <para>
   Por lo tanto, no es necesario abrir un flujo específico para, por ejemplo, <literal>stderr</literal> pero se puede usar simplemente la constante correspondiente a ese flujo:
   <programlisting role="shell">
<![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
   </programlisting>
   No es necesario cerrar explícitamente estos flujos, ya que se cerrarán automáticamente por PHP al final de su script.
  </para>

  <note>
   <para>
    Estas constantes no están disponibles cuando se lee un script PHP desde <literal>stdin</literal>.
   </para>
  </note>
 </section>
 <!--}}}-->

 <!--Interactive shell: {{{-->
 <section xml:id="features.commandline.interactive">
  <title>Shell Interactivo</title>

  <para>
   El &cli.sapi; proporciona un shell interactivo al usar la opción <option>-a</option> si PHP se ha compilado con la opción <option role="configure">--with-readline</option>. Desde PHP 7.1.0, el shell interactivo también está disponible en Windows, si la extensión <link linkend="book.readline">readline</link> está activada.
  </para>

  <para>
   Al usar el shell interactivo, tiene la posibilidad de escribir código PHP y que se ejecute directamente.
  </para>

  <example>
   <title>Ejecución de código usando el shell interactivo</title>
   <programlisting role="shell">
<![CDATA[
$ php -a
Interactive shell

php > echo 5+8;
13
php > function addTwo($n)
php > {
php { return $n + 2;
php { }
php > var_dump(addtwo(2));
int(4)
php >
]]>
   </programlisting>
  </example>

  <simpara>
   El shell interactivo también proporciona autocompletado de funciones, constantes, nombres de clases, variables, llamadas a métodos estáticos y constantes de clases utilizando la tecla de tabulación. Desde PHP 8.4.0, la ruta hacia el archivo de historial puede establecerse utilizando la variable de entorno <envar>PHP_HISTFILE</envar>.
  </simpara>

  <example>
   <title>Autocompletado usando la tecla de tabulación</title>
   <simpara>
    Presionar dos veces la tecla de tabulación cuando hay varias posibles completaciones mostrará una lista de estas completaciones:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > strp[TAB][TAB]
strpbrk   strpos    strptime
php > strp
]]>
   </programlisting>
   <simpara>
    Cuando solo hay una posible completación, presionar la tecla de tabulación una vez completará el resto en la misma línea:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > strpt[TAB]ime(
]]>
   </programlisting>
   <simpara>
    La completación también funcionará para los nombres que se han definido durante la sesión actual del shell interactivo:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > $fooThisIsAReallyLongVariableName = 42;
php > $foo[TAB]ThisIsAReallyLongVariableName
]]>
   </programlisting>
  </example>

  <para>
   El shell interactivo almacena su historial y puede acceder a él utilizando las teclas arriba y abajo. El historial se guarda en el archivo <filename>~/.php_history</filename>.
  </para>

  <para>
   El &cli.sapi; proporciona 2 directivas del &php.ini;: <parameter>cli.pager</parameter> y <parameter>cli.prompt</parameter>. La directiva <parameter>cli.pager</parameter> permite la definición de un programa externo (como <filename>less</filename>) a utilizar como pager para la salida en lugar de mostrarla directamente en la pantalla. La directiva <parameter>cli.prompt</parameter> permite la modificación del prompt <literal>php &gt;</literal>.
  </para>

  <para>
   También es posible definir directivas del &php.ini; en un shell interactivo utilizando notaciones abreviadas.
  </para>

  <example>
   <title>Definición de directivas del &php.ini; en un shell interactivo</title>
   <simpara>
    La definición de la directiva <parameter>cli.prompt</parameter>:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > #cli.prompt=hello world :>
hello world :>
]]>
   </programlisting>
   <simpara>
    Utilizando comillas invertidas, es posible ejecutar código PHP en el prompt:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > #cli.prompt=`echo date('H:i:s');` php >
15:49:35 php > echo 'hi';
hi
15:49:43 php > sleep(2);
15:49:45 php >
]]>
   </programlisting>
   <simpara>
    Definición del pager a <filename>less</filename>:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > #cli.pager=less
php > phpinfo();
(salida mostrada con less)
php >
]]>
   </programlisting>
  </example>

  <para>
   La directiva <parameter>cli.prompt</parameter> soporta algunas secuencias de escape:
   <table>
    <title>Secuencias de escape de <parameter>cli.prompt</parameter></title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Secuencia:</entry>
       <entry>Descripción:</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>\e</literal></entry>
       <entry>
        utilizado para agregar colores al prompt. Ejemplo:
        <literal>\e[032m\v \e[031m\b \e[34m\> \e[0m</literal>
       </entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>La versión de PHP.</entry>
      </row>
      <row>
       <entry><literal>\b</literal></entry>
       <entry>
        Indica en qué bloque de PHP nos encontramos. Por ejemplo, <literal>/*</literal> permite indicar que estamos en un comentario multilínea. El ámbito externo se representa por <literal>php</literal>.
       </entry>
      </row>
      <row>
       <entry><literal>\&gt;</literal></entry>
       <entry>
        Indica el carácter utilizado para el prompt. Por defecto, será <literal>&gt;</literal>, pero puede cambiarse cuando el shell se encuentra en un bloque indeterminado o en una cadena de caracteres. Los caracteres posibles son: <literal>' " {
        ( &gt;</literal>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  <note>
   <para>
    Los archivos incluidos a través de <link linkend="ini.auto-prepend-file">auto_prepend_file</link> y <link linkend="ini.auto-append-file">auto_append_file</link> se analizan en este modo, pero con algunas restricciones; es decir, las funciones deben haber sido definidas antes de la llamada.
   </para>
  </note>

  <section xml:id="features.commandline.interactive.mode">
   <title>Modo interactivo</title>
   <para>
    Si la extensión readline no está disponible, anterior a PHP 8.1.0, invocar el &cli.sapi; con la opción <option>-a</option> proporciona el modo interactivo. En este modo, se supone que se da un script PHP completo a través de STDIN, y después de la interrupción con
    <keycombo action='simul'>
     <keycap>CTRL</keycap>
     <keycap>D</keycap>
    </keycombo>
    (POSIX) o
    <keycombo action='simul'>
     <keycap>CTRL</keycap>
     <keycap>Z</keycap>
    </keycombo>
    seguido de <literal>ENTER</literal> (Windows), este script será evaluado. Esto es básicamente idéntico a invocar el &cli.sapi; sin la opción <option>-a</option>.
   </para>
   <para>
    A partir de PHP 8.1.0, invocar el &cli.sapi; con la opción <option>-a</option> falla si la extensión readline no está disponible.
   </para>
  </section>
 </section>
 <!--}}}-->

 <!--Built-in CLI Web Server: {{{-->
 <section xml:id="features.commandline.webserver">
  <title>Servidor web interno</title>

  <warning>
   <para>
    Este servidor web está destinado a ayudar en el desarrollo de aplicaciones. También puede ser útil para pruebas y para demostraciones de aplicaciones que se ejecutan en entornos controlados. Sin embargo, no está diseñado para ser un servidor web completo. Por lo tanto, no debe utilizarse en una red pública.
   </para>
  </warning>

  <para>
   El &cli.sapi; proporciona un servidor web interno.
  </para>

  <para>
   El servidor web se ejecuta en un solo proceso single-threaded, las aplicaciones PHP se retrasarán/suspenderán si una solicitud está bloqueada.
  </para>

  <para>
   Las solicitudes URI se sirven desde el directorio de trabajo actual donde se inició PHP, a menos que se utilice la opción -t para especificar explícitamente un documento raíz. Si una solicitud URI no especifica un archivo, entonces el archivo index.php o el archivo index.html del directorio actual será devuelto. Si ninguno de estos archivos existe, la búsqueda de un archivo index.php e index.html continuará en el directorio padre y así sucesivamente hasta que se encuentre uno de estos archivos o se alcance el directorio raíz. Si se encuentra un archivo index.php o index.html, se devolverá y $_SERVER['PATH_INFO'] se establecerá como la última parte de la URI. De lo contrario, se devolverá un código de respuesta 404.
  </para>

  <para>
   Si se proporciona un archivo PHP en la línea de comandos cuando se inicia el servidor web, se tratará como un script "ruteador". El script se ejecutará al inicio de cada solicitud HTTP. Si este script devuelve &false;, entonces el recurso solicitado se devolverá tal cual. De lo contrario, la salida del script se devolverá al navegador.
  </para>

  <para>
   Los tipos MIME estándar se devuelven para archivos con las extensiones:
   <simplelist type="inline">
    <member><literal>.3gp</literal></member>
    <member><literal>.apk</literal></member>
    <member><literal>.avi</literal></member>
    <member><literal>.bmp</literal></member>
    <member><literal>.css</literal></member>
    <member><literal>.csv</literal></member>
    <member><literal>.doc</literal></member>
    <member><literal>.docx</literal></member>
    <member><literal>.flac</literal></member>
    <member><literal>.gif</literal></member>
    <member><literal>.gz</literal></member>
    <member><literal>.gzip</literal></member>
    <member><literal>.htm</literal></member>
    <member><literal>.html</literal></member>
    <member><literal>.ics</literal></member>
    <member><literal>.jpe</literal></member>
    <member><literal>.jpeg</literal></member>
    <member><literal>.jpg</literal></member>
    <member><literal>.js</literal></member>
    <member><literal>.kml</literal></member>
    <member><literal>.kmz</literal></member>
    <member><literal>.m4a</literal></member>
    <member><literal>.mov</literal></member>
    <member><literal>.mp3</literal></member>
    <member><literal>.mp4</literal></member>
    <member><literal>.mpeg</literal></member>
    <member><literal>.mpg</literal></member>
    <member><literal>.odp</literal></member>
    <member><literal>.ods</literal></member>
    <member><literal>.odt</literal></member>
    <member><literal>.oga</literal></member>
    <member><literal>.ogg</literal></member>
    <member><literal>.ogv</literal></member>
    <member><literal>.pdf</literal></member>
    <member><literal>.png</literal></member>
    <member><literal>.pps</literal></member>
    <member><literal>.pptx</literal></member>
    <member><literal>.qt</literal></member>
    <member><literal>.svg</literal></member>
    <member><literal>.swf</literal></member>
    <member><literal>.tar</literal></member>
    <member><literal>.text</literal></member>
    <member><literal>.tif</literal></member>
    <member><literal>.txt</literal></member>
    <member><literal>.wav</literal></member>
    <member><literal>.webm</literal></member>
    <member><literal>.wmv</literal></member>
    <member><literal>.xls</literal></member>
    <member><literal>.xlsx</literal></member>
    <member><literal>.xml</literal></member>
    <member><literal>.xsl</literal></member>
    <member><literal>.xsd</literal></member>
    <member><literal>.zip</literal></member>
   </simplelist>
   .
  </para>

  <simpara>
   A partir de PHP 7.4.0, el servidor web integrado puede configurarse para bifurcar varios trabajadores para probar código que requiere múltiples solicitudes concurrentes al servidor web integrado. Establezca la variable de entorno <envar>PHP_CLI_SERVER_WORKERS</envar> en el número de trabajadores deseados antes de iniciar el servidor.
  </simpara>
  <note>
   <simpara>
    Esta funcionalidad no está soportada en Windows.
   </simpara>
  </note>
  <warning>
   <para>
    Esta funcionalidad <emphasis>experimental</emphasis> no está destinada a ser utilizada en producción. En general, el Servidor Web integrado no está destinado a ser utilizado en producción.
   </para>
  </warning>

  <example>
   <title>Inicio del servidor web</title>
   <programlisting role="shell">
<![CDATA[
$ cd ~/public_html
$ php -S localhost:8000
]]>
   </programlisting>
   <para>
    El terminal mostrará:
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit
]]>
   </screen>
   <para>
    Después de las solicitudes URI a http://localhost:8000/ y http://localhost:8000/myscript.html, el terminal mostrará algo como:
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit.
[Thu Jul 21 10:48:48 2011] ::1:39144 GET /favicon.ico - Request read
[Thu Jul 21 10:48:50 2011] ::1:39146 GET / - Request read
[Thu Jul 21 10:48:50 2011] ::1:39147 GET /favicon.ico - Request read
[Thu Jul 21 10:48:52 2011] ::1:39148 GET /myscript.html - Request read
[Thu Jul 21 10:48:52 2011] ::1:39149 GET /favicon.ico - Request read
]]>
   </screen>
   <para>
    Tenga en cuenta que antes de PHP 7.4.0, los recursos estáticos en enlace simbólico no son accesibles en Windows, a menos que el script ruteador lo maneje.
   </para>
  </example>

  <example>
   <title>Inicio con un directorio raíz específico</title>
   <programlisting role="shell">
<![CDATA[
$ cd ~/public_html
$ php -S localhost:8000 -t foo/
]]>
   </programlisting>
   <para>
    El terminal mostrará:
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:50:26 2011
Listening on localhost:8000
Document root is /home/me/public_html/foo
Press Ctrl-C to quit
]]>
   </screen>
  </example>

  <example>
   <title>Uso de un script ruteador</title>
   <para>
    En este ejemplo, solicitar imágenes las mostrará, pero las solicitudes de archivos HTML mostrarán "¡Bienvenido a PHP!".
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// router.php
if (preg_match('/\.(?:png|jpg|jpeg|gif)$/', $_SERVER["REQUEST_URI"])) {
    return false;    // devuelve la solicitud tal cual.
} else {
    echo "<p>¡Bienvenido a PHP!</p>";
}
?>]]>
   </programlisting>
   <programlisting role="shell">
<![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
  </example>

  <example>
   <title>Verificación de la utilización de CLI del servidor web</title>
   <para>
    Para reutilizar un script ruteador del marco durante el desarrollo con el CLI del servidor web y luego continuar utilizándolo con un servidor web de producción:
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// router.php
if (php_sapi_name() == 'cli-server') {
    /* Activar la ruta estática y devolver FALSE */
}
/* continuar con las operaciones de un index.php normal */
?>]]>
   </programlisting>
   <programlisting role="shell">
<![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
  </example>

  <example>
   <title>Manejo de tipos de archivos no soportados</title>
   <para>
    Si necesita servir un recurso estático para el cual el tipo MIME no es manejado por el CLI del servidor web, use esto:
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// router.php
$path = pathinfo($_SERVER["SCRIPT_FILENAME"]);
if ($path["extension"] == "el") {
    header("Content-Type: text/x-script.elisp");
    readfile($_SERVER["SCRIPT_FILENAME"]);
}
else {
    return FALSE;
}
?>]]>
   </programlisting>
   <programlisting role="shell">
<![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
  </example>

  <example>
   <title>Acceso al CLI del servidor web desde una máquina remota</title>
   <para>
    Puede hacer que el servidor web sea accesible en el puerto 8000 para todas las interfaces con:
   </para>
   <programlisting role="shell">
<![CDATA[
$ php -S 0.0.0.0:8000
]]>
   </programlisting>
   <warning>
    <para>
     El servidor web integrado no debe utilizarse en una red pública.
    </para>
   </warning>
  </example>

 </section>
 <!--}}}-->

 <section xml:id="features.commandline.ini">
  <title>Configuraciones INI</title>
  <para>
   <table>
    <title>Opciones de configuración CLI SAPI</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>&Name;</entry>
       <entry>&Default;</entry>
       <entry>&Changeable;</entry>
       <entry>&Changelog;</entry>
      </row>
     </thead>
     <tbody xml:id="features.commandline.ini.list">
      <row>
       <entry><link linkend="ini.cli-server.color">cli_server.color</link></entry>
       <entry>"0"</entry>
       <entry><constant>INI_ALL</constant></entry>
       <entry></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  &ini.descriptions.title;

  <para>
   <variablelist>
    <varlistentry xml:id="ini.cli-server.color">
     <term>
      <parameter>cli_server.color</parameter>
      <type>bool</type>
     </term>
     <listitem>
      <para>
       Activa el servidor web de desarrollo interno para utilizar la coloración ANSI del código en la salida del terminal.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </section>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
