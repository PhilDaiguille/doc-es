<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: e587d0655e426f97b3fcb431453da5030e743b23 Maintainer: PhilDaiguille Status: ready -->
<!-- Reviewed: no -->
<sect1 xml:id="language.types.array">
 <title>Los arrays</title>

 <para>
  Un array en PHP es en realidad un mapa ordenado. Un mapa es un tipo
  que asocia <emphasis>valores</emphasis> a <emphasis>claves</emphasis>.
  Este tipo está optimizado para diferentes usos; puede ser considerado
  como un array, una lista, una tabla hash, un diccionario, una
  colección, una pila, una cola y probablemente más. Se puede tener,
  como valor de un array, otros arrays, multidimensionales o no.
 </para>

 <para>
  La estructura de estos datos supera el objeto de este manual, pero encontrará
  al menos un ejemplo para cada uno de los casos mencionados. Para más información,
  consulte las diferentes explicaciones sobre el tema que se encuentran
  en la web.
 </para>

 <sect2 xml:id="language.types.array.syntax">
  <title>Sintaxis</title>

  <sect3 xml:id="language.types.array.syntax.array-func">
   <title>Sintaxis de un array</title>

   <para>
    Un array puede ser creado utilizando la estructura de lenguaje
    <function>array</function>. Toma un número ilimitado de parámetros,
    cada uno separado por una coma, en forma de un par
    <literal><replaceable>key</replaceable> =&gt;
    <replaceable>value</replaceable></literal>.
   </para>

   <synopsis>
array(
    <optional><replaceable>key</replaceable>  =&gt; </optional><replaceable>value</replaceable>,
    <optional><replaceable>key2</replaceable> =&gt; </optional><replaceable>value2</replaceable>,
    <optional><replaceable>key3</replaceable> =&gt; </optional><replaceable>value3</replaceable>,
    ...
)</synopsis>
   <!-- Do not fix the whitespace for the synopsis end element. A limitation of PhD prevents proper trimming -->

   <para>
    La coma después del último elemento de un array
    es opcional y puede no ser añadida. Generalmente, esto se hace para los arrays en una sola línea, i.e.
    <literal>array(1, 2)</literal> es preferido a <literal>array(1, 2, )</literal>.
    Para los arrays en varias líneas, la coma final generalmente
    se utiliza, ya que permite añadir más fácilmente nuevos elementos al
    final.
   </para>

   <note>
    <para>
     Existe una sintaxis de array corta que reemplaza
     <literal>array()</literal> por <literal>[]</literal>.
    </para>
   </note>

   <example>
    <title>Un array simple</title>
    <programlisting role="php">
<![CDATA[
<?php
$array1 = array(
    "foo" => "bar",
    "bar" => "foo",
);

// Utilizando la sintaxis de array corta
$array2 = [
    "foo" => "bar",
    "bar" => "foo",
];
?>
]]>
    </programlisting>
   </example>

   <para xml:id="language.types.array.key-casts">
    La clave <replaceable>key</replaceable> puede ser un <type>int</type>,
    o una &string;. El valor <replaceable>value</replaceable> puede ser
    de cualquier tipo.
   </para>

   <para>
    Además, las siguientes modificaciones de tipo ocurrirán para la clave <replaceable>key</replaceable> :
    <itemizedlist>
     <listitem>
      <simpara>
       Las cadenas de caracteres que contienen un entero válido, a menos que el número
       esté precedido por un signo <literal>+</literal> serán modificadas a un tipo
       entero. I.e. la clave <literal>"8"</literal> será actualmente almacenada como
       el entero <literal>8</literal>. Por otro lado, <literal>"08"</literal> no será
       modificada, sabiendo que no es un entero decimal válido.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Los números de punto flotante también serán modificados a entero, lo que significa
       que la parte después de la coma será truncada. I.e. la clave <literal>8.7</literal>
       será almacenada bajo el entero <literal>8</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Los booleanos también serán modificados a entero, i.e. la clave
       &true; será almacenada bajo el entero <literal>1</literal>
       y la clave &false; bajo el entero <literal>0</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       El valor <type>Null</type> será modificado a una cadena vacía, i.e. la clave
       <literal>null</literal> será almacenada bajo la cadena de caracteres <literal>""</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Los arrays y los objetos <emphasis>no pueden</emphasis> ser utilizados como clave.
       Si se intenta, se emitirá la siguiente alerta: <literal>Illegal offset type</literal>.
      </simpara>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Si varios elementos en la declaración de un array utilizan la misma clave,
    solo la última será utilizada, sobrescribiendo así todas las anteriores.
   </para>

   <example>
    <title>Ejemplo sobre la modificación de tipo y la sobrescritura</title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
    1    => "a",
    "1"  => "b",
    1.5  => "c",
    true => "d",
);
var_dump($array);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(1) {
  [1]=>
  string(1) "d"
}
]]>
    </screen>
    <para>
     Dado que todas las claves del ejemplo anterior son modificadas al entero
     <literal>1</literal>, el valor será sobrescrito en cada nuevo elemento,
     y solo el último cuyo valor asignado es <literal>"d"</literal> será
     conservado.
    </para>
   </example>

   <para>
    Los arrays PHP pueden contener claves de tipo
    <type>int</type> y <type>string</type> al mismo tiempo,
    dado que PHP no distingue entre arrays indexados y arrays asociativos.
   </para>

   <example>
    <title>Ejemplo con claves de tipo <type>int</type> y <type>string</type></title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
    "foo" => "bar",
    "bar" => "foo",
    100   => -100,
    -100  => 100,
);
var_dump($array);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(4) {
  ["foo"]=>
  string(3) "bar"
  ["bar"]=>
  string(3) "foo"
  [100]=>
  int(-100)
  [-100]=>
  int(100)
}
]]>
    </screen>
   </example>

   <para>
    La clave <replaceable>key</replaceable> es opcional. Si no se
    especifica, PHP utilizará un incremento de la última clave entera utilizada.
   </para>

   <example>
    <title>Arrays indexados sin clave</title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array("foo", "bar", "hello", "world");
var_dump($array);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(4) {
  [0]=>
  string(3) "foo"
  [1]=>
  string(3) "bar"
  [2]=>
  string(5) "hello"
  [3]=>
  string(5) "world"
}
]]>
    </screen>
   </example>

   <para>
    Es posible especificar la clave solo para algunos elementos
    y no proporcionarla para otros:
   </para>

   <example>
    <title>Ejemplo con claves solo para algunos elementos</title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
         "a",
         "b",
    6 => "c",
         "d",
);
var_dump($array);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(4) {
  [0]=>
  string(1) "a"
  [1]=>
  string(1) "b"
  [6]=>
  string(1) "c"
  [7]=>
  string(1) "d"
}
]]>
    </screen>
    <para>
     Como puede ver, el último valor <literal>"d"</literal>
     ha sido asignado a la clave <literal>7</literal>. Esto se debe a que
     la última clave entera más grande utilizada anteriormente era <literal>6</literal>.
    </para>
   </example>

   <example>
    <title>Ejemplo complejo sobre la modificación de tipo y la sobrescritura</title>
    <para>
     Este ejemplo incluye todas las variaciones de modificación de tipo de claves
     y sobrescrituras de los elementos.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
    1    => 'a',
    '1'  => 'b', // el valor "a" será sobrescrito por "b"
    1.5  => 'c', // el valor "b" será sobrescrito por "c"
    -1 => 'd',
    '01'  => 'e', // dado que esto no es una cadena de caracteres entera no SOBRESCRIBIRÁ la clave para 1
    '1.5' => 'f', // dado que esto no es una cadena de caracteres entera no SOBRESCRIBIRÁ la clave para 1
    true => 'g', // el valor "c" será sobrescrito por "g"
    false => 'h',
    '' => 'i',
    null => 'j', // el valor "i" será sobrescrito por "j"
    'k', // el valor "k" es asignado a la clave 2. Esto se debe a que la última clave entera más grande utilizada anteriormente era 1
    2 => 'l', // el valor "k" será sobrescrito por "l"
);
var_dump($array);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(7) {
  [1]=>
  string(1) "g"
  [-1]=>
  string(1) "d"
  ["01"]=>
  string(1) "e"
  ["1.5"]=>
  string(1) "f"
  [0]=>
  string(1) "h"
  [""]=>
  string(1) "j"
  [2]=>
  string(1) "l"
}
]]>
    </screen>
   </example>
   <example>
    <title>Ejemplo de índice negativo</title>
    <simpara>
     Cuando se asigna una clave entera negativa <literal>n</literal>, PHP se encargará
     de asignar la siguiente clave a <literal>n+1</literal>.
    </simpara>
    <programlisting role="php">
<![CDATA[
<?php
$array = [];

$array[-5] = 1;
$array[] = 2;

var_dump($array);
?>
]]>
    </programlisting>
     &example.outputs;
    <screen>
<![CDATA[
array(2) {
  [-5]=>
  int(1)
  [-4]=>
  int(2)
}
]]>
    </screen>

    <warning>
     <simpara>
      Anterior a PHP 8.3.0, la asignación de una clave entera negativa <literal>n</literal>
      asignaba la siguiente clave a <literal>0</literal>. El ejemplo anterior habría
      producido por lo tanto:
     </simpara>
     <informalexample>
      <screen>
<![CDATA[
array(2) {
  [-5]=>
  int(1)
  [0]=>
  int(2)
}
]]>
      </screen>
     </informalexample>
    </warning>
   </example>
  </sect3>

  <sect3 xml:id="language.types.array.syntax.accessing">
   <title>Acceso a los elementos de un array utilizando la sintaxis a base
    de corchetes</title>

   <para>
    Los elementos de un array pueden ser accedidos utilizando
    la sintaxis <literal>array[key]</literal>.
   </para>

   <example>
    <title>Acceso a los elementos de un array</title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
    "foo" => "bar",
    42    => 24,
    "multi" => array(
         "dimensional" => array(
             "array" => "foo"
         )
    )
);

var_dump($array["foo"]);
var_dump($array[42]);
var_dump($array["multi"]["dimensional"]["array"]);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
string(3) "bar"
int(24)
string(3) "foo"
]]>
    </screen>
   </example>

   <note>
    <para>
     Anterior a PHP 8.0.0, los corchetes y llaves podían ser utilizados de
     manera intercambiable para acceder a los elementos de un array (e.g.
     <literal>$array[42]</literal> y <literal>$array{42}</literal> harían
     ambos lo mismo en el ejemplo anterior).
     La sintaxis con las llaves fue deprecada en PHP 7.4.0 y ya no es
     soportada a partir de PHP 8.0.0.
    </para>
   </note>

   <example>
    <title>Referencia a un array a la salida de una función o un método</title>
    <programlisting role="php">
<![CDATA[
<?php
function getArray() {
    return array(1, 2, 3);
}

$secondElement = getArray()[1];

var_dump($secondElement);
?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     Un intento de acceso a una clave de un array que no ha sido definida
     equivale a intentar acceder a una variable no definida: se emitirá una alerta
     de nivel <constant>E_WARNING</constant> (E_NOTICE antes de PHP 8.0.0),
     y el resultado valdrá &null;.
    </para>
   </note>
   <note>
    <para>
     Referenciar a un array a la salida de una función o un método
     de un valor escalar que no es una &string; genera &null;.
     Anterior a PHP 7.4.0, esto no generaba ningún mensaje de error.
     A partir de PHP 7.4.0, esto emite una <constant>E_NOTICE</constant>;
     A partir de PHP 8.0.0, esto emite una <constant>E_WARNING</constant>.
    </para>
   </note>
  </sect3>

  <sect3 xml:id="language.types.array.syntax.modifying">
   <title>Creación/modificación con corchetes</title>

   <para>
    Un array existente puede ser modificado asignándole explícitamente valores.
   </para>

   <para>
    La asignación de un valor en un array se realiza especificando
    la clave, entre corchetes. La clave también puede no ser especificada, en la forma: <literal>[]</literal>.
   </para>

   <synopsis>
$arr[<replaceable>clé</replaceable>] = <replaceable>valeur</replaceable>;
$arr[] = <replaceable>valeur</replaceable>;
// <replaceable>clé</replaceable> puede ser un &integer; o una &string;
// <replaceable>valeur</replaceable> puede ser cualquier tipo</synopsis>

   <para>
    Si durante la asignación <varname>$arr</varname> no existe o está definido
    a &null; o &false;, será creado; es así una manera indirecta de crear un array.
    Esta práctica es, sin embargo, desaconsejada porque si <varname>$arr</varname>
    contiene ya algunos valores (i.e. <type>string</type> desde la variable solicitada)
    entonces este valor permanecerá en su lugar y <literal>[]</literal> puede esperar
    un <link linkend="language.types.string.substr">operador de acceso
    sobre una cadena</link>. Es siempre una mejor opción inicializar
    una variable por asignación directa.
   </para>
   <note>
    <simpara>
     A partir de PHP 7.1.0, la aplicación del operador de índice vacío sobre una
     cadena lanza una excepción fatal. Anteriormente, la cadena habría sido convertida
     silenciosamente en array.
    </simpara>
   </note>
   <note>
    <simpara>
     A partir de PHP 8.1.0, crear un nuevo array a partir de &false; es obsoleto.
     Crear un nuevo array desde &null; y los valores indefinidos sigue estando permitido.
    </simpara>
   </note>

   <para>
    Para modificar un valor en particular, es conveniente asignar un valor especificando
    su clave. Para borrar un par clave/valor, es conveniente llamar a la función
    <function>unset</function> sobre la clave deseada.
   </para>

   <example>
    <title>Uso de los corchetes con los arrays</title>
    <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // Idéntico a $arr[13] = 56;
                // en este punto del script

$arr["x"] = 42; // Esto añade un nuevo elemento al
                // array con la clave "x"

var_dump($arr);

unset($arr[5]); // Esto borra el elemento del array

unset($arr);    // Esto borra completamente el array

var_dump($arr);
?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     Como se dijo anteriormente, si no se especifica ninguna clave, el índice máximo
     existente es reutilizado, y la nueva clave será ese número, más 1 (pero al menos 0).
     Si no existe ningún índice entero, la clave será <literal>0</literal> (cero).
    </para>

    <para>
     Tenga en cuenta que la clave entera máxima para esta operación <emphasis>no necesita
     existir en el array en el momento de la manipulación</emphasis>.
     Solo debe haber existido en el array en algún momento desde la última vez que el array fue reindexado.
     Aquí hay un ejemplo que ilustra este principio:
    </para>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Creación de un array simple.
$array = array(1, 2, 3, 4, 5);
print_r($array);

// Ahora, eliminamos todos los elementos, pero conservamos el array:
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// Añadir un elemento (note que la nueva clave es 5, y no 0).
$array[] = 6;
print_r($array);

// Reindexación:
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
     </screen>
    </informalexample>

   </note>

  </sect3>

  <sect3 xml:id="language.types.array.syntax.destructuring">
   <title>Desestructuración de array</title>

   <para>
    Los arrays pueden ser desestructurados utilizando <literal>[]</literal>
    (a partir de PHP 7.1.0) o <function>list</function>.
    Estas construcciones pueden ser utilizadas para desestructurar un array en variables distintas.
   </para>

   <example>
    <title>Desestructuración de array</title>
    <programlisting role="php">
<![CDATA[
<?php
$tableau_source = ['foo', 'bar', 'baz'];

[$foo, $bar, $baz] = $tableau_source;

echo $foo, PHP_EOL;    // muestra "foo"
echo $bar, PHP_EOL;    // muestra "bar"
echo $baz, PHP_EOL;    // muestra "baz"
?>
]]>
    </programlisting>
   </example>

   <para>
    La desestructuración de array puede ser utilizada en un &foreach;
    para desestructurar un array multidimensional mientras se itera sobre él.
   </para>

   <example>
    <title>Desestructuración de array en un foreach</title>
    <programlisting role="php">
<![CDATA[
<?php
$tableau_source = [
    [1, 'John'],
    [2, 'Jane'],
];

foreach ($tableau_source as [$id, $name]) {
    echo "{$id}: '{$name}'\n";
}
?>
]]>
    </programlisting>
   </example>

   <para>
    Los elementos del array serán ignorados si la variable no es proporcionada.
    El array siempre comienza en el índice <literal>0</literal>.
   </para>

   <example>
    <title>Ignorar elementos</title>
    <programlisting role="php">
<![CDATA[
<?php
$tableau_source = ['foo', 'bar', 'baz'];

// Asigna el elemento situado en el índice 2 a la variable $baz
[, , $baz] = $tableau_source;

echo $baz;    // Muestra "baz"
?>
]]>
    </programlisting>
   </example>

   <para>
    A partir de PHP 7.1.0, los arrays asociativos también pueden ser desestructurados.
    Esto permite seleccionar más fácilmente el elemento correcto en los arrays
    indexados numéricamente, ya que el índice puede ser especificado explícitamente.
   </para>

   <example>
    <title>Desestructuración de array asociativo</title>
    <programlisting role="php">
<![CDATA[
<?php
$tableau_source = ['foo' => 1, 'bar' => 2, 'baz' => 3];

// Asigna el elemento situado en el índice 'baz' a la variable $three
['baz' => $three] = $tableau_source;

echo $three, PHP_EOL;    // Muestra "3"

$tableau_source = ['foo', 'bar', 'baz'];

// Asigna el elemento situado en el índice 2 a la variable $baz
[2 => $baz] = $tableau_source;

echo $baz, PHP_EOL;    // Muestra "baz"
?>
]]>
    </programlisting>
   </example>

   <para>
    La desestructuración de array puede ser utilizada para permutar fácilmente
    dos variables.
   </para>

   <example>
    <title>Permutar dos variables</title>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;

[$b, $a] = [$a, $b];

echo $a, PHP_EOL;    // Muestra 2
echo $b, PHP_EOL;    // Muestra 1
?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     El operador de descomposición (<literal>...</literal>) no es
     soportado en las asignaciones.
    </para>
   </note>

   <note>
    <para>
     Un intento de acceso a una clave de un array que no ha sido definida
     equivale a intentar acceder a una variable no definida: se emitirá una alerta
     de nivel <constant>E_WARNING</constant> (E_NOTICE antes de PHP 8.0.0),
     y el resultado valdrá &null;.
    </para>
   </note>
  </sect3>

 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.array.useful-funcs">
  <title>Funciones útiles</title>

  <para>
   Hay muchas funciones útiles para trabajar con los arrays.
   Se invita a leer la sección de este manual sobre las
   <link linkend="ref.array">funciones</link> en relación con los
   arrays.
  </para>

  <note>
   <para>
    La función <function>unset</function> permite borrar las claves de un array.
    Sea atento sobre el hecho de que el array no será <emphasis>no</emphasis>
    reindexado. Si desea realizar un borrado completo y una reindexación
    de su array, debe utilizar la función
    <function>array_values</function>.
   </para>

   <example>
    <title>Borrar elementos intermedios</title>
    <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'one', 2 => 'two', 3 => 'three');

/* producirá un array como este
   $a = array(1 => 'one', 3 => 'three');
   y NO un array como este
   $a = array(1 => 'one', 2 =>'three');
*/
unset($a[2]);
var_dump($a);

$b = array_values($a);
// Ahora, $b vale array(0 => 'one', 1 =>'three')
var_dump($b);
?>
]]>
    </programlisting>
   </example>
  </note>

  <para>
   La estructura de control &foreach; existe todo especialmente
   para los arrays. Proporciona una manera conveniente
   de recorrer un array.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.donts">
  <title>Lo que es posible hacer o no con un array</title>

  <sect3 xml:id="language.types.array.foo-bar">
   <title>¿Por qué <literal>$foo[bar]</literal> es incorrecto?</title>

   <para>
    Utilice siempre comillas alrededor de un índice literal. Por ejemplo,
    <literal>$foo['bar']</literal> es correcto, mientras que
    <literal>$foo[bar]</literal> no lo es. Pero ¿por qué? Es común
    encontrar este tipo de sintaxis en scripts antiguos:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'enemy';
echo $foo[bar];
// etc
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Esto es incorrecto, pero funciona. La razón es que este código tiene una constante
    indefinida (<literal>bar</literal>) en lugar de una &string;
    (<literal>'bar'</literal> - note las comillas).
    Esto funciona porque PHP convierte automáticamente una <emphasis>cadena desnuda</emphasis>
    (una cadena sin comillas que no corresponde a ningún símbolo conocido) en una cadena
    que la contiene. Actualmente, si no hay ninguna constante llamada <constant>bar</constant>,
    entonces PHP sustituirá <literal>'bar'</literal> en la cadena y la utilizará.
   </para>

   <warning>
    <simpara>
     La solución de recurso que considera una constante no definida como una
     cadena de caracteres desnuda es un error de nivel <constant>E_NOTICE</constant>.
     Esto es obsoleto a partir de PHP 7.2.0, y emite un error de nivel
     <constant>E_WARNING</constant>.
     A partir de PHP 8.0.0, esto ha sido retirado y lanza una excepción
     <classname>Error</classname>.
    </simpara>
   </warning>

   <simpara>
    Esto no significa que siempre se deban poner las claves entre comillas.
    No utilice comillas con las claves que son
    <link linkend="language.constants">constantes</link> o
    <link linkend="language.variables">variables</link>, ya que esto impediría que PHP
    las interpretara.
   </simpara>

   <example>
    <title>Clave entre comillas</title>
    <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);

// Array simple:
$array = array(1, 2);
$count = count($array);

for ($i = 0; $i < $count; $i++) {
    echo "\nVerificación de $i : \n";
    echo "Incorrecto: " . $array['$i'] . "\n";
    echo "Correcto: " . $array[$i] . "\n";
    echo "Incorrecto: {$array['$i']}\n";
    echo "Correcto: {$array[$i]}\n";
}
?>
]]>
     </programlisting>
    </example>
    &example.outputs;
    <screen>
<![CDATA[
Verificación de 0 :
Notice: Undefined index:  $i in /path/to/script.html on line 9
Incorrecto:
Correcto: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Incorrecto:
Correcto: 1

Verificación de 1 :
Notice: Undefined index:  $i in /path/to/script.html on line 9
Incorrecto:
Correcto: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Incorrecto:
Correcto: 2
]]>
   </screen>

   <para>
    Más ejemplos para explicar este comportamiento:
   </para>

   <example>
    <title>Más ejemplos</title>
    <programlisting role="php">
<![CDATA[
<?php
// Mostramos todos los errores
error_reporting(E_ALL);

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

// Correcto
echo $arr['fruit'], PHP_EOL;  // apple
echo $arr['veggie'], PHP_EOL; // carrot

// Incorrecto. Esto funciona pero PHP emitirá un error de tipo E_NOTICE porque
// se utiliza la constante llamada fruit que está indefinida
//
// Error: Undefined constant "fruit"
try {
    echo $arr[fruit];    // apple
} catch (Error $e) {
    echo get_class($e), ': ', $e->getMessage(), PHP_EOL;
}

// Esto define una constante para explicar lo que está mal. El valor 'veggie'
// es asignado a la constante llamada fruit.
define('fruit', 'veggie');

// Notar la diferencia ahora
echo $arr['fruit'], PHP_EOL;  // apple
echo $arr[fruit], PHP_EOL;    // carrot

// Lo siguiente es correcto, porque está en una cadena. Las constantes no son buscadas
// en las cadenas, y por lo tanto, no se emitirá ninguna alerta E_NOTICE
echo "Hello $arr[fruit], PHP_EOL";      // Hello apple

// Con una excepción: los paréntesis alrededor de un array en una cadena permiten
// que las constantes sean interpretadas
echo "Hello {$arr[fruit]}", PHP_EOL;    // Hello carrot
echo "Hello {$arr['fruit']}", PHP_EOL;  // Hello apple

// La concatenación es otra solución
echo "Hello " . $arr['fruit'], PHP_EOL; // Hello apple
?>
]]>
    </programlisting>
   </example>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// Esto no funcionará, y resultará en un error de análisis, como este:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Esto ocurre cuando se utiliza una superglobal en las cadenas
print "Hello $arr['fruit']";
print "Hello $_GET['foo']";
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Cuando <link linkend="ini.error-reporting">error_reporting</link> está definido para
    mostrar los errores de tipo <constant>E_NOTICE</constant> (definiéndolo a
    <constant>E_ALL</constant>, por ejemplo), tal práctica se vuelve inmediatamente
    visible. Por defecto,
    <link linkend="ini.error-reporting">error_reporting</link> no está definido para
    mostrar todas las alertas.
   </para>

   <para>
    Como se vio en la sección "<link linkend="language.types.array.syntax">sintaxis</link>",
    lo que se encuentra entre corchetes ('<literal>[</literal>' y
    '<literal>]</literal>') debe ser una expresión. Esto significa que el código siguiente
    funciona:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Este es un ejemplo de uso de una función que devuelve un valor que será
    la clave del array. PHP también entiende las constantes:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "A fatal error has occurred";
$error_descriptions[E_WARNING] = "PHP issued a warning";
$error_descriptions[E_NOTICE]  = "This is just an informal notice";
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Notar que <constant>E_ERROR</constant> también es un identificador válido,
    al igual que <literal>bar</literal> en el primer ejemplo. Pero el último
    ejemplo es finalmente el mismo que este:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "A fatal error has occurred";
$error_descriptions[2] = "PHP issued a warning";
$error_descriptions[8] = "This is just an informal notice";
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    porque <constant>E_ERROR</constant> vale <literal>1</literal>, etc.
   </para>

   <sect4 xml:id="language.types.array.foo-bar.why">
    <title>Entonces, ¿por qué es una mala práctica?</title>

    <para>
     En el futuro, los desarrolladores PHP pueden querer añadir otra
     constante o palabra clave, o bien una constante en otra parte
     del código que pueda interferir. Por ejemplo, siempre es incorrecto utilizar
     la palabra <literal>empty</literal> y <literal>default</literal>, sabiendo que son
     <link linkend="reserved">palabras reservadas</link>.
    </para>

    <note>
     <simpara>
      Para mayor claridad, en una cadena entre comillas dobles,
      es válido no rodear los índices de un array con comillas, y por lo tanto, <literal>"$foo[bar]"</literal> es válido. Ver
      los ejemplos a continuación para más detalles, pero también la sección sobre
      la <link linkend="language.types.string.parsing">interpretación de variables
      en las cadenas</link>.
     </simpara>
    </note>

   </sect4>
  </sect3>
 </sect2>

 <sect2 xml:id="language.types.array.casting">
  <title>Conversión en un array</title>

  <para>
   Para todos los tipos &integer;, &float;, &string;, &boolean; y &resource;,
   convertir un valor en un array resulta en un array que contiene
   un solo elemento cuyo índice vale cero y el valor, un valor escalar convertido.
   En otras palabras, <code>(array) $scalarValue</code> es exactamente lo mismo que <literal>array($scalarValue)</literal>.
  </para>

  <para>
   Si un objeto es convertido en un array, el resultado será un array cuyos
   elementos son las propiedades del objeto. Las claves son los nombres de los miembros,
   con una ligera excepción: las variables que tienen un nombre en forma de entero son
   inaccesibles; las variables privadas tendrán el nombre de la clase
   añadido al nombre de la variable; las variables protegidas tendrán un '*' añadido
   al nombre de la variable.
   Estos valores prefijados tienen bytes <literal>NUL</literal> en ambos lados.
   Las <link linkend="language.oop5.properties.typed-properties">propiedades tipadas</link>
   no inicializadas son silenciosamente desechadas.
  </para>

  <example>
   <title>Conversión en array</title>
   <programlisting role="php">
<![CDATA[
<?php
class A {
    private $B;
    protected $C;
    public $D;
    function __construct()
    {
        $this->{1} = null;
    }
}
var_export((array) new A());
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
array (
  '' . "\0" . 'A' . "\0" . 'B' => NULL,
  '' . "\0" . '*' . "\0" . 'C' => NULL,
  'D' => NULL,
  1 => NULL,
)
]]>
   </screen>
  </example>

  <para>
   Estos bytes <literal>NUL</literal> pueden llevar a resultados inesperados:
  </para>

  <example>
   <title>Conversión de un objeto en array</title>
   <programlisting role="php">
<![CDATA[
<?php

class A {
    private $A; // Esto se convierte en '\0A\0A'
}

class B extends A {
    private $A; // Esto se convierte en '\0B\0A'
    public $AA; // Esto se convierte en 'AA'
}

var_dump((array) new B());
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
array(3) {
  ["BA"]=>
  NULL
  ["AA"]=>
  NULL
  ["AA"]=>
  NULL
}
]]>
   </screen>
  </example>

  <para>
   Aquí, se podría pensar que hay 2 claves llamadas 'AA', mientras que una está
   actualmente llamada '\0A\0A'.
  </para>

  <para>
   La conversión de &null; en un array resulta en un array vacío.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.comparing">
  <title>Comparación</title>

  <para>
   Es posible comparar varios arrays con la función
   <function>array_diff</function> así como con los
   <link linkend="language.operators.array">operadores de arrays</link>.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.unpacking">
  <title>Desempaquetado de arrays</title>

  <para>
   Un array precedido por <code>...</code> será desempaquetado en su lugar durante la definición del array.
   Solo los arrays y los objetos que implementan <interfacename>Traversable</interfacename> pueden ser desempaquetados.
   El desempaquetado de array con <code>...</code> está disponible a partir de PHP 7.4.0.
  </para>

  <para>
   Es posible desempaquetar varias veces, y añadir elementos
   normales antes y después del operador <code>...</code>:

   <example>
    <title>Desempaquetado simple de array</title>
    <programlisting role="php">
<![CDATA[
<?php
// Utilización de la sintaxis de array corta.
// Funciona con array() también.
$arr2 = [...$arr1]; // [1, 2, 3]
$arr3 = [0, ...$arr1]; // [0, 1, 2, 3]
$arr4 = [...$arr1, ...$arr2, 111]; // [1, 2, 3, 1, 2, 3, 111]
$arr5 = [...$arr1, ...$arr1]; // [1, 2, 3, 1, 2, 3]

function getArr() {
  return ['a', 'b'];
}
$arr6 = [...getArr(), 'c' => 'd']; // ['a', 'b', 'c' => 'd']

var_dump($arr1, $arr2, $arr3, $arr4, $arr5, $arr6);
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   Desempaquetar un array con el operador <code>...</code> sigue las semánticas de la función <function>array_merge</function>.
   Es decir, que las claves posteriores sobrescriben los valores anteriores
   y las claves numéricas son renumeradas:

   <example>
    <title>Desempaquetado de array con clave duplicada</title>
    <programlisting role="php">
<![CDATA[
<?php
// string key
$arr1 = ["a" => 1];
$arr2 = ["a" => 2];
$arr3 = ["a" => 0, ...$arr1, ...$arr2];
var_dump($arr3); // ["a" => 2]

// integer key
$arr4 = [1, 2, 3];
$arr5 = [4, 5, 6];
$arr6 = [...$arr4, ...$arr5];
var_dump($arr6); // [1, 2, 3, 4, 5, 6]
// Which is [0 => 1, 1 => 2, 2 => 3, 3 => 4, 4 => 5, 5 => 6]
// where the original integer keys have not been retained.
?>
]]>
    </programlisting>
   </example>
  </para>

  <note>
   <para>
    Las claves que no son ni enteros ni cadenas lanzan una <classname>TypeError</classname>.
    Tales claves solo pueden ser generadas por un objeto <interfacename>Traversable</interfacename>.
   </para>
  </note>
  <note>
   <para>
    Anterior a PHP 8.1, el desempaquetado de array que tenía una clave en forma de cadena no era soportado:
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php

$arr1 = [1, 2, 3];
$arr2 = ['a' => 4];
$arr3 = [...$arr1, ...$arr2];
// Fatal error: Uncaught Error: Cannot unpack array with string keys in example.php:5

$arr4 = [1, 2, 3];
$arr5 = [4, 5];
$arr6 = [...$arr4, ...$arr5]; // funciona. [1, 2, 3, 4, 5]
?>
]]>
    </programlisting>
   </informalexample>
  </note>

 </sect2>

 <sect2 xml:id="language.types.array.examples">
  <title>Ejemplos</title>

  <para>
   El tipo array en PHP es realmente versátil. Aquí hay algunos ejemplos:
  </para>

  <example>
   <title>Versatilidad de un array</title>
   <programlisting role="php">
<![CDATA[
<?php
// Esto
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
             4        // la clave será 0
          );

$b = array('a', 'b', 'c');

var_dump($a, $b);

// es estrictamente equivalente a
$a = array();
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name']  = 'apple';
$a[]        = 4;        // la clave será 0

$b = array();
$b[] = 'a';
$b[] = 'b';
$b[] = 'c';

// Después de la ejecución del código anterior, $a será el array
// array('color' => 'red', 'taste' => 'sweet', 'shape' => 'round',
// 'name' => 'apple', 0 => 4), y $b será el array
// array(0 => 'a', 1 => 'b', 2 => 'c'), o simplemente array('a', 'b', 'c').
var_dump($a, $b);
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>Uso de array()</title>
   <programlisting role="php">
<![CDATA[
<?php
// Array como mapa de propiedades
$map = array( 'version'    => 4,
              'OS'         => 'Linux',
              'lang'       => 'english',
              'short_tags' => true
            );
var_dump($map);

// claves numéricas estrictas
// es idéntico a array(0 => 7, 1 => 8, ...)
$array = array( 7,
                8,
                0,
                156,
                -10
              );
var_dump($array);

$switching = array(         10, // clave = 0
                    5    =>  6,
                    3    =>  7,
                    'a'  =>  4,
                            11, // clave = 6 (el índice entero máximo es 5)
                    '8'  =>  2, // clave = 8 (entero!)
                    '02' => 77, // clave = '02'
                    0    => 12  // el valor 10 será sobrescrito por el valor 12
                  );
var_dump($switching);

// array vacío
$empty = array();
var_dump($empty);
?>
]]>
   </programlisting>
  </example>

  <example xml:id="language.types.array.examples.loop">
   <title>Colección</title>
   <programlisting role="php">
<![CDATA[
<?php
$colors = array('rojo', 'azul', 'verde', 'amarillo');

foreach ($colors as $color) {
    echo "¿Le gusta el color $color ?\n";
}

?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
¿Le gusta el color rojo ?
¿Le gusta el color azul ?
¿Le gusta el color verde ?
¿Le gusta el color amarillo ?
]]>
   </screen>
  </example>

  <para>
   La modificación directa de valores de un <type>array</type> es posible
   pasándolo por referencia.
  </para>

  <example xml:id="language.types.array.examples.changeloop">
   <title>Modificación de un elemento en el bucle</title>
   <programlisting role="php">
<![CDATA[
<?php
foreach ($colors as &$color) {
    $color = mb_strtoupper($color);
}
unset($color); /* Nos aseguramos de que las escrituras posteriores
sobre $color no modifiquen el último elemento del array */

print_r($colors);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Array
(
    [0] => ROJO
    [1] => AZUL
    [2] => VERDE
    [3] => AMARILLO
)
]]>
    </screen>
   </example>

  <para>
   Este ejemplo crea un array, cuya indexación comienza en 1.
  </para>

  <example>
   <title>Indexación comenzando en 1</title>
   <programlisting role="php">
<![CDATA[
<?php
$firstquarter = array(1 => 'Enero', 'Febrero', 'Marzo');
print_r($firstquarter);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Array
(
    [1] => Enero
    [2] => Febrero
    [3] => Marzo
)
]]>
    </screen>
   </example>

  <example>
   <title>Llenado de un array</title>
   <programlisting role="php">
<![CDATA[
<?php
// Llena un array con todos los elementos de un directorio
$handle = opendir('.');
while (false !== ($file = readdir($handle))) {
    $files[] = $file;
}
closedir($handle);
var_dump($files);
?>
]]>
    </programlisting>
   </example>

  <para>
   Los arrays están ordenados. El orden puede ser modificado utilizando varias
   funciones. Vea la sección sobre las <link linkend="ref.array">funciones sobre los
   arrays</link> para más información. La función <function>count</function>
   puede ser utilizada para contar el número de elementos de un array.
  </para>

  <example>
   <title>Ordenación de un array</title>
   <programlisting role="php" annotations="non-interactive">
<![CDATA[
<?php
sort($files);
print_r($files);
?>
]]>
    </programlisting>
   </example>

  <para>
   Dado que el valor de un array puede ser cualquier cosa, también puede ser
   otro array. Esto permite la creación de arrays recursivos
   y arrays multidimensionales.
  </para>

  <example>
   <title>Arrays recursivos y multidimensionales</title>
   <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banana",
                                       "c" => "apple"
                                     ),
                  "numbers" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "holes"   => array (      "first",
                                       5 => "second",
                                            "third"
                                     )
                );
var_dump($fruits);

// Algunos ejemplos para encontrar los valores en el array anterior
echo $fruits["holes"][5];    // muestra "second"
echo $fruits["fruits"]["a"]; // muestra "orange"
unset($fruits["holes"][0]);  // borra "first"

// Creación de un array multidimensional
$juices["apple"]["green"] = "good";
var_dump($juices);
?>
]]>
    </programlisting>
   </example>

  <para>
   La asignación de un array implica siempre la copia de los valores.
   Utilice el <link linkend="language.operators">operador de referencia</link>
   para copiar un array por referencia.
  </para>

  <example>
   <title>Copiar arrays</title>
   <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 es modificado,
             // $arr1 sigue valiendo array(2, 3)

$arr3 = &$arr1;
$arr3[] = 4; // ahora, $arr1 y $arr3 son idénticos

var_dump($arr1, $arr2, $arr3);
?>
]]>
    </programlisting>
   </example>

 </sect2>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
