<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: e587d0655e426f97b3fcb431453da5030e743b23 Maintainer: yannick Status: ready -->
<!-- Reviewed: no Maintainer: PhilDaiguille -->
<sect1 xml:id="language.types.string">
 <title>Cadenas</title>

 <para>
  Un <type>string</type> es una serie de caracteres, donde un carácter es
  el mismo que un byte. Esto significa que PHP solo admite un conjunto
  de 256 caracteres y, por lo tanto, no ofrece soporte nativo para Unicode. Ver
  <link linkend="language.types.string.details">los detalles del tipo string</link>.
 </para>

 <note>
  <simpara>
   En versiones de 32 bits, un <type>string</type> puede ser tan grande como 2 Go
   (2147483647 bytes máximo)
  </simpara>
 </note>

 <sect2 xml:id="language.types.string.syntax">
  <title>Sintaxis</title>

  <para>
   Un <type>string</type> literal puede ser especificado de cuatro maneras diferentes :
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">entre comillas simples</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">entre comillas dobles</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">sintaxis heredoc</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.nowdoc">sintaxis nowdoc</link>
    </simpara>
   </listitem>
  </itemizedlist>

  <sect3 xml:id="language.types.string.syntax.single">
   <title>Entre comillas simples</title>

   <para>
    La manera más simple de especificar un <type>string</type> es encerrarlo entre comillas
    simples (el carácter <literal>'</literal>).
   </para>

   <para>
    Para especificar una comilla simple literal, escápela con una barra invertida
    (<literal>\</literal>). Para especificar una barra invertida literal, duplíquela
    (<literal>\\</literal>). Todas las demás apariciones de la barra invertida serán tratadas
    como una barra invertida literal : esto significa que las demás secuencias de escape que pueda
    conocer, tales como <literal>\r</literal> o <literal>\n</literal>,
    serán emitidas literalmente como se especificó en lugar de tener un significado especial.
   </para>

   <note>
    <simpara>
     A diferencia de las <link linkend="language.types.string.syntax.double">comillas dobles</link>
     y <link linkend="language.types.string.syntax.heredoc">sintaxis heredoc</link>,
     las <link linkend="language.variables">variables</link> y las secuencias de escape
     para los caracteres especiales <emphasis>no</emphasis> serán <emphasis>no</emphasis> expandidas
     cuando se encuentren en <type>strings</type> entre comillas simples.
    </simpara>
   </note>

   <example>
    <title>Variantes de sintaxis</title>
    <programlisting role="php">
<![CDATA[
<?php
echo 'esto es un string simple', PHP_EOL;

echo 'También puede tener nuevas líneas integradas en
los strings de esta manera, porque es admisible hacerlo.', PHP_EOL;

// Muestra : Arnold dijo una vez : "Volveré"
echo 'Arnold dijo una vez : "Volveré"', PHP_EOL;

// Muestra : ¿Ha eliminado C:\*.* ?
echo '¿Ha eliminado C:\\*.* ?', PHP_EOL;

// Muestra : ¿Ha eliminado C:\*.* ?
echo '¿Ha eliminado C:\*.* ?', PHP_EOL;

// Muestra : Esto no se expandirá : \n una nueva línea
echo 'Esto no se expandirá : \n una nueva línea', PHP_EOL;

// Muestra : Las variables no $s\'expandirán $tampoco
echo 'Las variables no $s\'expandirán $tampoco', PHP_EOL;
?>
]]>
    </programlisting>
   </example>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.double">
   <title>Entre comillas dobles</title>

   <para>
    Si el <type>string</type> está encerrado entre comillas dobles (<literal>"</literal>), PHP interpretará
    las siguientes secuencias de escape para caracteres especiales :
   </para>

   <table>
    <title>Caracteres escapados</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Secuencia</entry>
       <entry>Significado</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>retorno de línea (LF o 0x0A (10) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>retorno de carro (CR o 0x0D (13) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>tabulación horizontal (HT o 0x09 (9) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>tabulación vertical (VT o 0x0B (11) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\e</literal></entry>
       <entry>escape (ESC o 0x1B (27) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>avance de formulario (FF o 0x0C (12) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>barra invertida</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>signo de dólar</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>comilla doble</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        Octal : la secuencia de caracteres correspondiente a la expresión regular <literal>[0-7]{1,3}</literal>
        es un carácter en notación octal (por ejemplo, <literal>"\101" === "A"</literal>),
        que se desborda silenciosamente para ajustarse a un byte (por ejemplo, <literal>"\400" === "\000"</literal>)
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        Hexadecimal : la secuencia de caracteres correspondiente a la expresión regular
        <literal>[0-9A-Fa-f]{1,2}</literal> es un carácter en notación hexadecimal
        (por ejemplo, <literal>"\x41" === "A"</literal>)
       </entry>
      </row>
      <row>
       <entry><literal>\u{[0-9A-Fa-f]+}</literal></entry>
       <entry>
        Unicode : la secuencia de caracteres correspondiente a la expresión regular <literal>[0-9A-Fa-f]+</literal>
        es un punto de código Unicode, que será emitido en el string bajo la representación UTF-8 de ese punto de código.
        Las llaves son requeridas en la secuencia. Por ejemplo, <literal>"\u{41}" === "A"</literal>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
<para>
    Al igual que con los <type>strings</type> entre comillas simples, escapar cualquier otro carácter
    también imprimirá la barra invertida.
</para>

<para>
    La característica más importante de los <type>strings</type> entre comillas dobles es el hecho
    de que los nombres de variables serán expandidos. Ver
    <link linkend="language.types.string.parsing">la interpolación de strings</link> para
    más detalles.
</para>
</sect3>

<sect3 xml:id="language.types.string.syntax.heredoc">
   <title>Heredoc</title>

   <simpara>
    Una tercera manera de delimitar los <type>strings</type> es la sintaxis heredoc :
    <literal>&lt;&lt;&lt;</literal>. Después de este operador, se
    proporciona un identificador, luego una nueva línea. El <type>string</type> en sí sigue, luego
    el mismo identificador nuevamente para cerrar la cita.
   </simpara>

   <simpara>
    El identificador de cierre puede ser sangrado por espacios o tabulaciones, en cuyo caso
    la sangría será eliminada de todas las líneas en el string doc.
    Antes de PHP 7.3.0, el identificador de cierre <emphasis>debe</emphasis>
    comenzar en la primera columna de la línea.
   </simpara>

   <simpara>
    Además, el identificador de cierre debe seguir las mismas reglas de nomenclatura que cualquier
    otra etiqueta en PHP : debe contener solo caracteres alfanuméricos y
    guiones bajos, y debe comenzar con un carácter no numérico o un guión bajo.
   </simpara>

   <example>
    <title>Ejemplo básico de Heredoc a partir de PHP 7.3.0</title>
    <programlisting role="php">
<![CDATA[
<?php
// sin sangría
echo <<<END
      a
     b
    c
\n
END;

// 4 espacios de sangría
echo <<<END
      a
     b
    c
    END;
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
      a
     b
    c

  a
 b
c
]]>
    </screen>
   </example>

   <simpara>
    Si el identificador de cierre está sangrado más que cualquier línea del cuerpo, entonces se levantará un <classname>ParseError</classname> :
   </simpara>

   <example>
    <title>El identificador de cierre no debe estar sangrado más que ninguna línea del cuerpo</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<END
  a
 b
c
   END;
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
Parse error: Invalid body indentation level (expecting an indentation level of at least 3) in example.php on line 4
]]>
    </screen>
   </example>

   <simpara>
    Si el identificador de cierre está sangrado, también se pueden usar tabulaciones, sin embargo,
    las tabulaciones y los espacios <emphasis>no deben</emphasis> mezclarse en cuanto a
    la sangría del identificador de cierre y la sangría del cuerpo
    (hasta el identificador de cierre). En uno de estos casos, se levantará un <classname>ParseError</classname>.

    Estas restricciones de espacio se han incluido porque mezclar espacios y tabulaciones para la sangría perjudica la legibilidad.
   </simpara>

   <example>
    <title>Diferente sangría para el cuerpo (espacios) identificador de cierre</title>
    <programlisting role="php" annotations="non-interactive">
<![CDATA[
<?php
// Todo el código siguiente no funciona.

// diferente sangría para el cuerpo (espacios) marcador de fin (tabulaciones)
{
	echo <<<END
	 a
		END;
}

// mezcla de espacios y tabulaciones en el cuerpo
{
    echo <<<END
    	a
     END;
}

// mezcla de espacios y tabulaciones en el marcador de fin
{
	echo <<<END
		  a
		 END;
}
]]>
</programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
Parse error: Invalid indentation - tabs and spaces cannot be mixed in example.php line 8
]]>
    </screen>
   </example>

   <simpara>
    El identificador de cierre para el string del cuerpo no es requerido para ser
    seguido de un punto y coma o un salto de línea. Por ejemplo, el siguiente código
    está permitido a partir de PHP 7.3.0 :
   </simpara>

   <example>
    <title>Continuación de una expresión después de un identificador de cierre</title>
    <programlisting role="php">
<![CDATA[
<?php
$values = [<<<END
a
  b
    c
END, 'd e f'];
var_dump($values);
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
array(2) {
  [0] =>
  string(11) "a
  b
    c"
  [1] =>
  string(5) "d e f"
}
]]>
    </screen>
   </example>

   <warning>
    <simpara>
     Si el identificador de cierre se encontró al comienzo de una línea, entonces
     no importa si formaba parte de otra palabra, puede considerarse
     como el identificador de cierre y provocar un <classname>ParseError</classname>.
    </simpara>

    <example>
     <title>El identificador de cierre en el cuerpo del string tiende a provocar un ParseError</title>
     <programlisting role="php">
<![CDATA[
<?php
$values = [<<<END
a
b
END ING
END, 'd e f'];
]]>
     </programlisting>
     &example.outputs.73;
    <screen>
<![CDATA[
Parse error: syntax error, unexpected identifier "ING", expecting "]" in example.php on line 5
]]>
     </screen>
    </example>

    <simpara>
     Para evitar este problema, es seguro seguir la regla simple :
     <emphasis>no elegir como identificador de cierre si aparece en el cuerpo
     del texto</emphasis>.
    </simpara>

   </warning>

   <warning>
    <simpara>
     Antes de PHP 7.3.0, es muy importante tener en cuenta que la línea que contiene el
     identificador de cierre no debe contener ningún otro carácter, excepto un punto y coma
     (<literal>;</literal>).
     Esto significa sobre todo que el identificador
     <emphasis>no puede estar sangrado</emphasis>, y no debe haber espacios
     o tabulaciones antes o después del punto y coma. También es importante darse cuenta de que
     el primer carácter antes del identificador de cierre debe ser un salto de línea tal
     como se define por el sistema operativo local. Es <literal>\n</literal> en
     los sistemas UNIX, incluyendo macOS. El delimitador de cierre también debe ser
     seguido de un salto de línea.
    </simpara>

    <simpara>
     Si se infringe esta regla y el identificador de cierre no es "limpio", no se
     considerará como un identificador de cierre, y PHP continuará buscando uno. Si no se encuentra un
     identificador de cierre adecuado antes del final del archivo
     actual, se producirá un error de análisis en la última línea.
    </simpara>

    <example>
     <title>Ejemplo no válido, antes de PHP 7.3.0</title>
     <programlisting role="php">
      <!-- Este es un ejemplo NO VÁLIDO -->
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
    EOT;
}
// El identificador no debe estar sangrado
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Ejemplo válido, incluso antes de PHP 7.3.0</title>
     <programlisting role="php">
      <!-- Este es un ejemplo VÁLIDO -->
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>

    <para>
     Los heredocs que contienen variables no pueden usarse para inicializar propiedades de clase.
    </para>

   </warning>

   <para>
    El texto heredoc se comporta exactamente como un <type>string</type> entre comillas dobles, sin las comillas. Esto significa que las comillas dentro de un heredoc no necesitan ser escapadas, pero los códigos de escape mencionados anteriormente aún pueden ser utilizados. Las variables se expanden, pero se debe tener el mismo cuidado al expresar variables complejas dentro de un heredoc que para los <type>strings</type>.
   </para>

   <example>
    <title>Ejemplo de cita de string heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Ejemplo de string
extendiéndose en varias líneas
usando la sintaxis heredoc.
EOD;

/* Ejemplo más complejo, con variables. */
class foo
{
    var $foo;
    var $bar;

    function __construct()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
Mi nombre es "$name". Estoy imprimiendo $foo->foo.
Ahora, imprimo {$foo->bar[1]}.
Esto debería imprimir una 'A' mayúscula : \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Mi nombre es "MyName". Estoy imprimiendo Foo.
Ahora, imprimo Bar2.
Esto debería imprimir una 'A' mayúscula : A]]>
    </screen>
   </example>

   <para>
    También es posible usar la sintaxis heredoc para pasar datos a los argumentos de función :
   </para>

   <example>
    <title>Heredoc en los ejemplos de argumentos</title>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(array(<<<EOD
foobar!
EOD
));
?>
]]>
    </programlisting>
   </example>

   <para>
    Es posible inicializar variables estáticas y propiedades/constantes de clase usando la sintaxis heredoc :
   </para>

   <example>
    <title>Uso de Heredoc para inicializar valores estáticos</title>
    <programlisting role="php" annotations="non-interactive">
<![CDATA[
<?php
// Variables estáticas
function foo()
{
    static $bar = <<<LABEL
Nada aquí...
LABEL;
}

// Propiedades/constantes de clase
class foo
{
    const BAR = <<<FOOBAR
Ejemplo de constante
FOOBAR;

    public $baz = <<<FOOBAR
Ejemplo de propiedad
FOOBAR;
}
?>
]]>
</programlisting>
   </example>

   <para>
    El identificador de apertura del Heredoc puede eventualmente ser
    encerrado entre comillas dobles :
   </para>

   <example>
    <title>Uso de comillas dobles en el Heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<"FOOBAR"
¡Hola mundo!
FOOBAR;
?>
]]>
    </programlisting>
   </example>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.nowdoc">
   <title>Nowdoc</title>

   <para>
    Los nowdocs son para los strings entre comillas simples lo que los heredocs son para los strings entre comillas dobles. Un nowdoc se especifica de manera similar a un heredoc, pero <emphasis>no se realiza ninguna interpolación de string</emphasis> dentro de un nowdoc. La construcción es ideal para integrar código PHP u otros bloques de texto voluminosos sin necesidad de escapar. Comparte algunas características con la construcción SGML
    <literal>&lt;![CDATA[ ]]&gt;</literal>, en el sentido de que declara un
    bloque de texto que no está destinado a ser analizado.
   </para>

   <para>
    Un nowdoc se identifica por la misma secuencia <literal>&lt;&lt;&lt;</literal>
    utilizada para los heredocs, pero el identificador que sigue está encerrado entre comillas simples, por ejemplo <literal>&lt;&lt;&lt;'EOT'</literal>. Todas las reglas para los identificadores heredoc se aplican también a los identificadores nowdoc, en particular las que se refieren a la aparición del identificador de cierre.
   </para>

   <example>
    <title>Ejemplo de cita de string nowdoc</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<'EOD'
Ejemplo de string extendiéndose en varias líneas
usando la sintaxis nowdoc. Las barras invertidas siempre se tratan literalmente,
es decir \\ y \'.
EOD;
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Ejemplo de string extendiéndose en varias líneas
usando la sintaxis nowdoc. Las barras invertidas siempre se tratan literalmente,
es decir \\ y \'.
]]>
    </screen>
   </example>

   <example>
    <title>Ejemplo de cita de string nowdoc con variables</title>
    <programlisting role="php">
<![CDATA[
<?php
class foo
{
    public $foo;
    public $bar;

    function __construct()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<'EOT'
Mi nombre es "$name". Estoy imprimiendo $foo->foo.
Ahora, imprimo {$foo->bar[1]}.
Esto no debería imprimir una 'A' mayúscula : \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Mi nombre es "$name". Estoy imprimiendo $foo->foo.
Ahora, imprimo {$foo->bar[1]}.
Esto no debería imprimir una 'A' mayúscula : \x41]]>
    </screen>
   </example>

   <example>
    <title>Ejemplo de datos estáticos</title>
    <programlisting role="php" annotations="non-interactive">
<![CDATA[
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
</programlisting>
   </example>

  </sect3>

  <sect3 xml:id="language.types.string.parsing">
   <title>Interpolación de strings</title>

   <simpara>
    Cuando un <type>string</type> se especifica entre comillas dobles o con heredoc,
    las <link linkend="language.variables">variables</link> pueden ser sustituidas en su interior.
   </simpara>

   <simpara>
    Existen dos tipos de sintaxis : una
    <link linkend="language.types.string.parsing.basic">básica</link> y una
    <link linkend="language.types.string.parsing.advanced">avanzada</link>.
    La sintaxis básica es la más común y la más práctica. Ofrece una manera de incorporar una variable, un valor <type>array</type> o una propiedad <type>objeto</type> en un <type>string</type> con un mínimo de esfuerzo.
   </simpara>

   <sect4 xml:id="language.types.string.parsing.basic">
    <title>Sintaxis básica</title>
    <simpara>
     Si se encuentra un signo de dólar (<literal>$</literal>), los caracteres que le siguen y que pueden ser utilizados en un nombre de variable serán interpretados como tales y sustituidos.
    </simpara>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$juice = "manzana";

echo "Ha bebido un poco de $juice jugo." . PHP_EOL;

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Ha bebido un poco de manzana jugo.
]]>
     </screen>
    </informalexample>

    <simpara>
     Formalmente, la estructura para la sintaxis de sustitución de variable básica es la siguiente :
    </simpara>
    <example>
     <title>Interpolación de strings</title>
     <programlisting>
<![CDATA[
string-variable::
     variable-name   (offset-or-property)?
   | ${   expression   }

offset-or-property::
     offset-in-string
   | property-in-string

offset-in-string::
     [   name   ]
   | [   variable-name   ]
   | [   integer-literal   ]

property-in-string::
     ->  name

variable-name::
     $   name

name::
     [a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*

]]>
     </programlisting>
    </example>

    <warning>
     <para>
      La sintaxis <literal>${ expression }</literal> está deprecada desde
      PHP 8.2.0, ya que puede ser interpretada como
      <link linkend="language.variables.variable">variables de variables</link> :
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
const foo = 'bar';
$foo = 'foo';
$bar = 'bar';
var_dump("${foo}");
var_dump("${(foo)}");
?>
]]>
       </programlisting>
       &example.outputs.82;
       <screen>
<![CDATA[
Deprecado : Usar ${var} en strings está deprecado, use {$var} en su lugar en el archivo en la línea 6

Deprecado : Usar ${expr} (variables de variables) en strings está deprecado, use {${expr}} en su lugar en el archivo en la línea 9
string(3) "foo"
string(3) "bar"
]]>
       </screen>
       &example.outputs;
       <screen>
<![CDATA[
string(3) "foo"
string(3) "bar"
]]>
       </screen>
      </informalexample>
      La sintaxis de interpolación de string <link linkend="language.types.string.parsing.advanced">avanzada</link> debería usarse en su lugar.
     </para>
    </warning>

    <note>
     <simpara>
      Si no es posible formar un nombre válido, el signo de dólar
      se mantendrá tal cual en el string :
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo "No se ha producido ninguna interpolación $  n\n";
echo "No se ha producido ninguna interpolación $\n n\n";
echo "No se ha producido ninguna interpolación $2 n\n";
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
No se ha producido ninguna interpolación $  n
No se ha producido ninguna interpolación $
 n
No se ha producido ninguna interpolación $2 n
]]>
      </screen>
    </informalexample>
    </note>

    <example>
     <title>Interpolación del valor de la primera dimensión de un array o de una propiedad</title>
     <programlisting role="php">
<![CDATA[
<?php
$juices = array("manzana", "naranja", "string_key" => "violeta");

echo "Ha bebido un poco de $juices[0] jugo.";
echo PHP_EOL;
echo "Ha bebido un poco de $juices[1] jugo.";
echo PHP_EOL;
echo "Ha bebido un poco de $juices[string_key] jugo.";
echo PHP_EOL;

class A {
    public $s = "string";
}

$o = new A();

echo "Valor del objeto : $o->s.";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Ha bebido un poco de manzana jugo.
Ha bebido un poco de naranja jugo.
Ha bebido un poco de violeta jugo.
Valor del objeto : string.
]]>
     </screen>
    </example>

    <note>
     <simpara>
      La clave del array debe estar sin comillas, y por lo tanto no es posible
      referenciar una constante como clave con la sintaxis básica. Use la
      sintaxis <link linkend="language.types.string.parsing.advanced">avanzada</link>
      en su lugar.
     </simpara>
    </note>

    <simpara>
     Desde PHP 7.1.0, los índices numéricos <emphasis>negativos</emphasis> también
     son soportados.
    </simpara>

    <example><title>Índices numéricos negativos</title>
     <programlisting role="php">
<![CDATA[
<?php
$string = 'string';
echo "El carácter en el índice -2 es $string[-2].", PHP_EOL;
$string[-3] = 'o';
echo "Cambiar el carácter en el índice -3 a o da $string.", PHP_EOL;
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
El carácter en el índice -2 es n.
Cambiar el carácter en el índice -3 a o da strong.
]]>
     </screen>
    </example>

    <simpara>
     Para todo lo que es más complejo, la
     <link linkend="language.types.string.parsing.advanced">sintaxis avanzada</link>
     debe ser utilizada.
    </simpara>
   </sect4>

   <sect4 xml:id="language.types.string.parsing.advanced">
    <title>Sintaxis avanzada (sintaxis de llaves)</title>

    <simpara>
     La sintaxis avanzada permite la interpolación de
     <emphasis>variables</emphasis> con accesores arbitrarios.
    </simpara>

    <simpara>
     Cualquier variable escalar, elemento de array o propiedad de objeto
     (<modifier>static</modifier> o no) con una representación
     <type>string</type> puede ser incluida a través de esta sintaxis.
     La expresión se escribe de la misma manera que la que aparecería fuera de la
     <type>string</type>, luego se encierra entre <literal>{</literal> y
     <literal>}</literal>. Dado que <literal>{</literal> no puede ser escapado, esta
     sintaxis solo será reconocida cuando el <literal>$</literal> siga inmediatamente al
     <literal>{</literal>. Use <literal>{\$</literal> para obtener un
     <literal>{$</literal>. Aquí hay algunos ejemplos para aclarar :
    </simpara>

     <example>
     <title>Sintaxis con llaves</title>
     <programlisting role="php">
<![CDATA[
<?php
const DATA_KEY = 'const-key';
$great = 'fantástico';
$arr = [
    '1',
    '2',
    '3',
    [41, 42, 43],
    'key' => 'Valor indexado',
    'const-key' => 'Clave con un signo menos',
    'foo' => ['foo1', 'foo2', 'foo3']
];

// No funcionará, muestra : This is { fantastic}
echo "Esto es { $great}";

// Funciona, muestra : This is fantastic
echo "Esto es {$great}";

class Square {
    public $width;

    public function __construct(int $width) { $this->width = $width; }
}

$square = new Square(5);

// Funciona
echo "Este cuadrado mide {$square->width}00 centímetros de ancho.";

// Funciona, las claves entre comillas solo funcionan con la sintaxis de llaves
echo "Esto funciona : {$arr['key']}";

// Funciona
echo "Esto funciona : {$arr[3][2]}";

echo "Esto funciona : {$arr[DATA_KEY]}";

// Al usar arrays multidimensionales, use siempre llaves alrededor de los arrays
// cuando estén dentro de strings
echo "Esto funciona : {$arr['foo'][2]}";

echo "Esto funciona : {$obj->values[3]->name}";

echo "Esto funciona : {$obj->$staticProp}";

// No funcionará, muestra : C:\directory\{fantastic}.txt
echo "C:\directory\{$great}.txt";

// Funciona, muestra : C:\directory\fantastic.txt
echo "C:\\directory\\{$great}.txt";
?>
]]>
     </programlisting>
    </example>

    <note>
     <simpara>
      Dado que esta sintaxis permite expresiones arbitrarias, es posible usar
      <link linkend="language.variables.variable">variables de variables</link>
      en la sintaxis avanzada.
     </simpara>
    </note>
   </sect4>
  </sect3>

  <sect3 xml:id="language.types.string.substr">
   <title>Acceso y modificación de string por carácter</title>

   <para>
    Los caracteres en los <type>strings</type> pueden ser accedidos y modificados especificando
    el desplazamiento basado en cero del carácter deseado después del
    <type>string</type> usando corchetes <type>array</type>, como en
    <varname>$str[42]</varname>. Piense en un <type>string</type> como un
    <type>array</type> de caracteres para este propósito. Las funciones
    <function>substr</function> y <function>substr_replace</function>
    pueden ser utilizadas cuando se desea extraer o reemplazar más de un carácter.
   </para>

   <note>
    <simpara>
     Desde PHP 7.1.0, los desplazamientos de string negativos también son soportados. Estos especifican
     el desplazamiento desde el final del string.
     Anteriormente, los desplazamientos negativos emitían <constant>E_NOTICE</constant> para la lectura
     (produciendo un string vacío) y <constant>E_WARNING</constant> para la escritura
     (dejando el string intacto).
    </simpara>
   </note>

   <note>
    <simpara>
     Antes de PHP 8.0.0, los <type>strings</type> también podían ser accedidos usando llaves, como en
     <varname>$str{42}</varname>, para el mismo propósito.
     Esta sintaxis de llaves ha sido deprecada desde PHP 7.4.0 y ya no es soportada desde PHP 8.0.0.
    </simpara>
   </note>

   <warning>
    <simpara>
     Escribir en un desplazamiento fuera de alcance llena el string con espacios.
     Los tipos no enteros se convierten en enteros.
     Un tipo de desplazamiento ilegal emite <constant>E_WARNING</constant>.
     Solo se utiliza el primer carácter de un string asignado.
     Desde PHP 7.1.0, asignar un string vacío genera un error fatal. Anteriormente,
     esto asignaba un byte NULL.
    </simpara>
   </warning>

   <warning>
    <simpara>
     Internamente, los strings PHP son arrays de bytes. En consecuencia, acceder o
     modificar un string usando corchetes de array no es seguro para los multi-bytes, y
     no debería hacerse más que con strings en codificación de un solo byte como ISO-8859-1.
    </simpara>
   </warning>

   <note>
    <simpara>
     Desde PHP 7.1.0, aplicar el operador de índice vacío a un string vacío genera un error fatal.
     Anteriormente, el string vacío se convertía silenciosamente en un array.
    </simpara>
   </note>

   <example>
    <title>Algunos ejemplos de strings</title>
    <programlisting role="php">
<![CDATA[
<?php
// Obtener el primer carácter de un string
$str = 'Esto es una prueba.';
$first = $str[0];
var_dump($first);

// Obtener el tercer carácter de un string
$third = $str[2];
var_dump($third);

// Obtener el último carácter de un string.
$str = 'Esto sigue siendo una prueba.';
$last = $str[strlen($str)-1];
var_dump($last);

// Modificar el último carácter de un string
$str = 'Mira el mar';
$str[strlen($str)-1] = 'e';
var_dump($str);
?>
]]>
    </programlisting>
   </example>

   <para>
    Los desplazamientos de string deben ser enteros o strings que se asemejan a enteros,
    de lo contrario se emitirá una advertencia.
   </para>

   <example>
    <title>Ejemplo de desplazamientos de string ilegales</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = 'abc';

foreach ($keys as $keyToTry) {
    var_dump(isset($str[$keyToTry]));

    try {
        var_dump($str[$keyToTry]);
    } catch (TypeError $e) {
        echo $e->getMessage(), PHP_EOL;
    }

    echo PHP_EOL;
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
string(1) "b"

bool(false)
Cannot access offset of type string on string

bool(false)
Cannot access offset of type string on string

bool(false)

Warning: Illegal string offset "1x" in Standard input code on line 10
string(1) "b"
]]>
    </screen>
   </example>

   <note>
    <para>
     Acceder a variables de otros tipos (con la excepción de arrays o objetos
     que implementen las interfaces apropiadas) usando <literal>[]</literal> o
     <literal>{}</literal> devuelve silenciosamente &null;.
    </para>
   </note>

   <note>
    <para>
     Los caracteres en los literales de string pueden ser accedidos
     usando <literal>[]</literal> o <literal>{}</literal>.
    </para>
   </note>

   <note>
    <para>
     Acceder a caracteres en literales de string usando la
     sintaxis <literal>{}</literal> ha sido deprecado en PHP 7.4.
     Esto ha sido eliminado en PHP 8.0.
    </para>
   </note>
  </sect3>
 </sect2><!-- fin de la sintaxis -->

 <sect2 xml:id="language.types.string.useful-funcs">
  <title>Funciones y operadores útiles</title>

  <para>
   Los <type>strings</type> pueden ser concatenados usando el operador '.' (punto). Tenga en cuenta
   que el operador '+' (adición) no funcionará <emphasis>no</emphasis> para esto.
   Consulte <link linkend="language.operators.string">los operadores de string</link> para
   más información.
  </para>

  <para>
   Hay varias funciones útiles para la manipulación de <type>strings</type>.
  </para>

  <simpara>
   Consulte la <link linkend="ref.strings">sección de funciones de string</link> para
   las funciones generales, y la <link linkend="ref.pcre">sección de funciones de expresiones regulares compatibles con Perl</link> para
   funcionalidades avanzadas de búsqueda y reemplazo.
  </simpara>

  <simpara>
   También hay <link linkend="ref.url">funciones para strings de URL</link>, y
   funciones para cifrar/descifrar strings
   (<link linkend="ref.sodium">Sodium</link> y
   <link linkend="ref.hash">Hash</link>).
  </simpara>

  <simpara>
   Finalmente, consulte también las <link linkend="ref.ctype">funciones de tipo de carácter</link>.
  </simpara>
 </sect2>

 <sect2 xml:id="language.types.string.casting">
  <title>Conversión a string</title>

  <para>
   Un valor puede ser convertido en <type>string</type> usando el
   cast <literal>(string)</literal> o la función <function>strval</function>.
   La conversión a <type>string</type> se realiza automáticamente en el contexto de una
   expresión donde se necesita un <type>string</type>. Esto ocurre al usar las
   funciones <function>echo</function> o <function>print</function>, o cuando
   una variable se compara con un <type>string</type>. Las secciones sobre
   <link linkend="language.types">Tipos</link> y
   <link linkend="language.types.type-juggling">Type Juggling</link> aclararán
   lo que sigue. Vea también la función <function>settype</function>.
  </para>

  <para>
   Un valor <type>bool</type> &true; se convierte en el <type>string</type>
   <literal>"1"</literal>. El <type>bool</type> &false; se convierte en
   <literal>""</literal> (el string vacío). Esto permite una conversión de ida y vuelta entre
   los valores <type>bool</type> y <type>string</type>.
  </para>

  <para>
   Un <type>int</type> o <type>float</type> se convierte en un
   <type>string</type> que representa el número textualmente (incluyendo la
   parte exponente para los <type>float</type>). Los números de punto flotante pueden ser
   convertidos usando la notación exponente (<literal>4.1E+6</literal>).
  </para>

  <note>
   <para>
    A partir de PHP 8.0.0, el carácter de la coma decimal es siempre
    un punto ("<literal>.</literal>"). Antes de PHP 8.0.0,
    el carácter de la coma decimal se define en la configuración regional del script (categoría
    LC_NUMERIC). Consulte la función <function>setlocale</function>.
   </para>
  </note>

  <para>
   Los <type>arrays</type> siempre se convierten en el <type>string</type>
   <literal>"Array"</literal>; por lo tanto, <function>echo</function> y
   <function>print</function> no pueden por sí solos mostrar el contenido de un
   <type>array</type>. Para mostrar un solo elemento, use una construcción como
   <literal>echo $arr['foo']</literal>. Consulte a continuación consejos sobre la visualización de todo el contenido.
  </para>

  <para>
   Para convertir <type>objetos</type> en <type>strings</type>, debe usarse el método mágico
   <link linkend="language.oop5.magic">__toString</link>.
  </para>

  <para>
   Los <type>recursos</type> siempre se convierten en <type>strings</type> con la
   estructura <literal>"Resource id #1"</literal>, donde <literal>1</literal>
   es el número de recurso asignado al <type>recurso</type> por PHP en
   la ejecución. Aunque la estructura exacta de este string no debe considerarse como
   confiable y está sujeta a cambios, siempre será única para un recurso dado
   durante la duración de la ejecución de un script (es decir, una solicitud web o un proceso CLI)
   y no será reutilizada. Para obtener el tipo de un <type>recurso</type>, use
   la función <function>get_resource_type</function>.
  </para>

  <para>
   &null; siempre se convierte en un string vacío.
  </para>

  <para>
   Como se indicó anteriormente, convertir directamente un <type>array</type>,
   un <type>objeto</type> o un <type>recurso</type> en <type>string</type> no proporciona
   información útil sobre el valor más allá de su tipo. Consulte las funciones
   <function>print_r</function> y <function>var_dump</function> para
   formas más eficaces de inspeccionar el contenido de estos tipos.
  </para>

  <para>
   La mayoría de los valores PHP también pueden ser convertidos en <type>strings</type> para un almacenamiento permanente.
   Este método se llama serialización y se realiza mediante la función
   <function>serialize</function>.
  </para>

 </sect2>
<sect2 xml:id="language.types.string.details">

  <title>Detalles del tipo string</title>

  <para>
   El <type>string</type> en PHP se implementa como un array de bytes y un
   entero que indica la longitud del búfer. No tiene información sobre cómo
   estos bytes se traducen en caracteres, dejando esta tarea al programador.
   No hay limitaciones sobre los valores que puede tener el string; en
   particular, los bytes de valor <literal>0</literal> (« bytes NUL ») están permitidos
   en cualquier lugar del string (sin embargo, algunas funciones, llamadas en este manual no
   ser « seguras para binarios », pueden pasar los strings a bibliotecas
   que ignoran los datos después de un byte NUL).
  </para>
  <para>
   Esta naturaleza del tipo string explica por qué no hay un tipo « byte » distinto
   en PHP – los strings toman este rol. Las funciones que no devuelven datos
   textuales – por ejemplo, datos arbitrarios leídos de un socket de red –
   devolverán strings de todos modos.
  </para>
  <para>
   Dado que PHP no dicta una codificación específica para los strings, uno podría
   preguntarse cómo se codifican los literales de string. Por ejemplo, el string
   <literal>"á"</literal> ¿es equivalente a <literal>"\xE1"</literal> (ISO-8859-1),
   <literal>"\xC3\xA1"</literal> (UTF-8, forma C),
   <literal>"\x61\xCC\x81"</literal> (UTF-8, forma D) o cualquier otra representación
   posible? La respuesta es que el string se codificará de la manera en que está
   codificado en el archivo de script. Así, si el script está escrito en ISO-8859-1, el
   string se codificará en ISO-8859-1 y viceversa. Sin embargo, esto no se aplica
   si Zend Multibyte está habilitado; en ese caso, el script puede estar escrito en una
   codificación arbitraria (que se declara explícitamente o se detecta) y luego se convierte
   en una cierta codificación interna, que luego será la codificación utilizada para los
   literales de string.
   Tenga en cuenta que hay algunas restricciones sobre la codificación del script (o sobre la codificación
   interna, si Zend Multibyte está habilitado) – esto generalmente significa que esta
   codificación debe ser un superconjunto compatible de ASCII, como UTF-8 o ISO-8859-1.
   Tenga en cuenta, sin embargo, que las codificaciones dependientes del estado donde los mismos valores de bytes
   pueden ser utilizados en estados de desplazamiento iniciales y no iniciales pueden
   ser problemáticas.
  </para>
  <para>
   Por supuesto, para ser útiles, las funciones que operan sobre texto pueden necesitar
   hacer ciertas suposiciones sobre cómo está codificado el string. Desafortunadamente,
   hay mucha variación en esto en las funciones de PHP :
  </para>
  <itemizedlist>
   <listitem>
    <simpara>
     Algunas funciones suponen que el string está codificado en un (cualquier) conjunto de caracteres
     de un byte, pero no necesitan interpretar estos bytes como caracteres específicos. Este es el caso, por ejemplo, de
     <function>substr</function>, <function>strpos</function>, <function>strlen</function> o
     <function>strcmp</function>. Otra forma de pensar en estas funciones es que operan sobre búferes de memoria, es decir,
     que funcionan con bytes y desplazamientos de bytes.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Otras funciones reciben la codificación del string, suponiendo eventualmente un valor predeterminado si no se proporciona tal información. Este es el caso de
     <function>htmlentities</function> y la mayoría de las funciones en
     la <link linkend="book.mbstring">extensión mbstring</link>.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Otras usan la configuración regional actual (ver <function>setlocale</function>),
     pero funcionan byte a byte.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     También pueden simplemente suponer que el string usa una codificación
     específica, generalmente UTF-8. Este es el caso de la mayoría de las funciones en
     la <link linkend="book.intl">extensión intl</link> y en
     la <link linkend="book.pcre">extensión PCRE</link>
     (en este último caso, solo cuando se usa el modificador <literal>u</literal>).
    </simpara>
   </listitem>
  </itemizedlist>

  <para>
   En última instancia, esto significa que escribir programas correctos usando
   Unicode depende de evitar cuidadosamente las funciones que no funcionarán y que muy probablemente
   corromperán los datos, y usar en su lugar las funciones que se comportan correctamente, generalmente provenientes de las extensiones
   <link linkend="book.intl">intl</link> y <link linkend="book.mbstring">mbstring</link>.
   Sin embargo, usar funciones capaces de manejar las codificaciones Unicode es solo el comienzo. Independientemente de las funciones que proporcione el lenguaje, es esencial conocer la especificación Unicode. Por ejemplo, un programa que asume que solo hay mayúsculas y minúsculas hace una suposición incorrecta.
  </para>
 </sect2>
</sect1><!-- fin string -->

<!-- Mantener este comentario al final del archivo
Variables locales:
modo: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimizar-atributos:nil
sgml-siempre-citar-atributos:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-documento-padre:nil
sgml-dtd-archivo-predeterminado:"~/.phpdoc/manual.ced"
sgml-etiquetas-expuestas:nil
sgml-catálogos-locales:nil
sgml-archivos-ecat-locales:nil
Fin:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
