<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: f4f96ef8b2a95283c92ea2183fe1dedf06f3ad22 Maintainer: PhilDaiguille Status: ready -->
<!-- Reviewed: no -->
<!-- CREDITS: DAnnebicque -->
<chapter xml:id="language.namespaces" xmlns="http://docbook.org/ns/docbook"
 version="1.1">
 <title>Los espacios de nombres</title>

 <sect1 xml:id="language.namespaces.rationale">
  <title>Introducción a los espacios de nombres</title>
  <titleabbrev>Introducción</titleabbrev>
  <?phpdoc print-version-for="namespaces"?>
  <simpara>
   ¿Qué son los espacios de nombres? En su definición más amplia, representan
   un medio para encapsular elementos. Esto puede ser concebido como un concepto
   abstracto, por varias razones. Por ejemplo, en un sistema de ficheros, los
   directorios representan un grupo de ficheros asociados y sirven de espacio de nombres
   para los ficheros que contienen. Un ejemplo concreto es que el fichero
   <literal>foo.txt</literal> puede existir en los dos directorios
   <literal>/home/greg</literal> y <literal>/home/other</literal>, pero que
   las dos copias de <literal>foo.txt</literal> no pueden coexistir
   en el mismo directorio. Además, para acceder al fichero <literal>foo.txt</literal>
   desde fuera del directorio <literal>/home/greg</literal>, es necesario especificar
   el nombre del directorio utilizando un separador de directorios, tal como
   <literal>/home/greg/foo.txt</literal>. El mismo principio se aplica a los
   espacios de nombres en el mundo de la programación.
  </simpara>

  <simpara>
   En el mundo PHP, los espacios de nombres están diseñados para resolver dos problemas
   que encuentran los autores de bibliotecas y aplicaciones al reutilizar
   elementos como clases o bibliotecas de funciones:
  </simpara>
  <para>
   <orderedlist>
    <listitem>
     <simpara>
      Colisiones de nombres entre el código que se crea, las clases, funciones
      o constantes internas de PHP, o las de bibliotecas de terceros.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      La capacidad de hacer alias o acortar Nombres_Extremadamente_Largos
      para ayudar a resolver el primer problema y mejorar la legibilidad
      del código.
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <simpara>
   Los espacios de nombres PHP proporcionan un medio para agrupar clases, interfaces,
   funciones o constantes. A continuación se muestra un ejemplo de sintaxis de los espacios de nombres PHP:
  </simpara>
  <example>
   <title>Ejemplo de sintaxis de los espacios de nombres</title>
   <titleabbrev>Espacios de nombres</titleabbrev>
   <programlisting role="php">
   <![CDATA[
<?php
namespace mi\nombre; // véase la sección "Definir espacios de nombres"

class MiClase {}
function mifunción() {}
const MICONSTANTE = 1;

$a = new MiClase;
$c = new \mi\nombre\MiClase; // véase la sección "Espacio global"

$a = strlen('hola'); // véase la sección "Utilizar espacios de nombres: una
                     // alternativa a funciones/constantes globales"

$d = namespace\MICONSTANTE; // véase la sección "El operador namespace y
                            // la constante __NAMESPACE__"
$d = __NAMESPACE__ . '\MICONSTANTE';
echo constant($d); // véase la sección "Espacios de nombres y características dinámicas del lenguaje"
?>
    ]]>
   </programlisting>
  </example>
   <note>
    <simpara>
     Los nombres de los espacios de nombres no son sensibles a la casilla.
    </simpara>
   </note>
  <note>
   <para>
    Los espacios de nombres <literal>PHP</literal>, así como los nombres compuestos
    que comienzan con estos nombres (como <literal>PHP\Classes</literal>)
    están reservados para el uso interno del lenguaje y no deben ser utilizados
    en el código del espacio de usuario.
   </para>
  </note>
 </sect1>

 <sect1 xml:id="language.namespaces.definition">
  <title>Definición de los espacios de nombres</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Aunque el código PHP válido puede estar contenido en un espacio de nombres,
   solo los siguientes tipos de código pueden ser afectados por los espacios de nombres:
   las clases (incluyendo las abstractas y los traits), las interfaces,
   las funciones y las constantes.
  </para>
  <para>
   Los espacios de nombres se declaran con la palabra clave <literal>namespace</literal>.
   Un fichero que contiene un espacio de nombres debe declarar el espacio al principio
   del fichero, antes de cualquier otro código, con una sola excepción: la palabra
   clave <xref linkend="control-structures.declare" />.
   <example>
    <title>Declaración de un espacio de nombres</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MiProyecto;

const CONECTAR_OK = 1;
class Conexión { /* ... */ }
function conectar() { /* ... */ }

?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Los nombres completamente calificados (es decir, los nombres que comienzan con un antislash)
     no están autorizados en las declaraciones de espacios de nombres, ya que tales
     construcciones se interpretan como expresiones de espacio de nombres relativo.
    </simpara>
   </note>
   El único elemento autorizado antes de la declaración de espacio de nombres es la instrucción
   <literal>declare</literal>, para definir la codificación del fichero fuente. Además,
   ningún código no-PHP puede preceder la declaración de espacio de nombres, incluyendo
   espacios:
   <example>
    <title>Error de declaración de un espacio de nombres</title>
    <programlisting role="php">
     <![CDATA[
<html>
<?php
namespace MiProyecto; // error fatal - el espacio de nombres debe ser la primera sentencia del script
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Además, a diferencia de otras estructuras PHP, el mismo espacio de nombres puede
   ser definido en varios ficheros, lo que permite dividir el contenido de un
   espacio de nombres en varios ficheros.
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.nested">
  <title>Declaración de un subespacio de nombres</title>
  <titleabbrev>Subespacio de nombres</titleabbrev>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Al igual que los ficheros y los directorios, los espacios de nombres también
   son capaces de especificar una jerarquía de espacios de nombres. Así, un nombre de espacio
   de nombres puede ser definido con sus subniveles:
   <example>
    <title>Declaración de un espacio de nombres con jerarquía</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MiProyecto\Sub\Nivel;

const CONECTAR_OK = 1;
class Conexión { /* ... */ }
function conectar() { /* ... */  }

?>
]]>
    </programlisting>
   </example>
   En el ejemplo anterior, la constante <literal>MonProjet\Sous\Niveau\CONNEXION_OK</literal>,
   la clase <literal>MonProjet\Sous\Niveau\Connexion</literal> y la función
   <literal>MonProjet\Sous\Niveau\connecte</literal> se crean.
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.definitionmultiple">
  <title>Definición de varios espacios de nombres en el mismo fichero</title>
  <titleabbrev>Definición de varios espacios de nombres en el mismo fichero</titleabbrev>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Varios espacios de nombres también pueden ser declarados en el mismo fichero.
   Hay dos sintaxis autorizadas.
  </para>
  <para>
   <example>
    <title>Declaración de varios espacios de nombres, sintaxis de combinación simple</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MiProyecto;

const CONECTAR_OK = 1;
class Conexión { /* ... */ }
function conectar() { /* ... */  }

namespace OtroProyecto;

const CONECTAR_OK = 1;
class Conexión { /* ... */ }
function conectar() { /* ... */  }
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Esta sintaxis no es recomendada para combinar espacios de nombres
   en un solo fichero. En su lugar, se recomienda utilizar
   la sintaxis de llaves.
  </para>
  <para>
   <example>
    <title>Declaración de varios espacios de nombres, sintaxis de llaves</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MiProyecto {

const CONECTAR_OK = 1;
class Conexión { /* ... */ }
function conectar() { /* ... */  }
}

namespace OtroProyecto {

const CONECTAR_OK = 1;
class Conexión { /* ... */ }
function conectar() { /* ... */  }
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Se recomienda encarecidamente, como práctica de codificación, no mezclar
   varios espacios de nombres en el mismo fichero. El uso recomendado es combinar
   varios scripts PHP en el mismo fichero.
  </para>
  <para>
   Para combinar varios códigos sin espacios de nombres en código con espacio de nombres,
   solo se soporta la sintaxis de llaves. El código global debe estar encuadrado por un
   espacio de nombres sin nombre, tal como este:
   <example>
    <title>Declaración de varios espacios de nombres con un espacio sin nombre</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MiProyecto {

const CONECTAR_OK = 1;
class Conexión { /* ... */ }
function conectar() { /* ... */  }
}

namespace { // código global
session_start();
$a = MiProyecto\conectar();
echo MiProyecto\Conexión::iniciar();
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Ningún código PHP puede existir fuera de las llaves del espacio de nombres,
   salvo para abrir una nueva instrucción <literal>declare</literal>.
   <example>
    <title>Declaración de varios espacios de nombres con un espacio sin nombre (2)</title>
    <programlisting role="php">
     <![CDATA[
<?php
declare(encoding='UTF-8');
namespace MiProyecto {

const CONECTAR_OK = 1;
class Conexión { /* ... */ }
function conectar() { /* ... */  }
}

namespace { // código global
session_start();
$a = MiProyecto\conectar();
echo MiProyecto\Conexión::iniciar();
}
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.basics">
  <title>Uso de los espacios de nombres: introducción</title>
  <titleabbrev>Introducción</titleabbrev>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Antes de discutir el uso de los espacios de nombres, es importante comprender
   cómo PHP deduce qué espacio de nombres utiliza su código. Se puede hacer una analogía
   simple entre los espacios de nombres de PHP y un sistema de ficheros. Hay tres maneras
   de acceder a un fichero en un sistema de ficheros:
   <orderedlist>
    <listitem>
     <simpara>
      Un nombre de fichero relativo, como <literal>foo.txt</literal>. Esto se resuelve
      en <literal>directoriocorriente/foo.txt</literal> donde <literal>directoriocorriente</literal> es el
      directorio de trabajo. Si el directorio actual es <literal>/home/foo</literal>,
      este nombre se resuelve en <literal>/home/foo/foo.txt</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Una ruta relativa, como <literal>subdirectorio/foo.txt</literal>. Esto se
      resuelve en <literal>directoriocorriente/subdirectorio/foo.txt</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Una ruta absoluta, como <literal>/main/foo.txt</literal>. Esto se resuelve
      en <literal>/main/foo.txt</literal>.
     </simpara>
    </listitem>
   </orderedlist>
   El mismo principio puede ser aplicado a los espacios de nombres de PHP.
   Por ejemplo, se puede hacer referencia a una clase de tres maneras:
   <orderedlist>
    <listitem>
     <simpara>
      Un nombre sin calificativo, o una clase sin prefijo, como
      <literal>$a = new foo();</literal> o
      <literal>foo::methodestatique();</literal>. Si el espacio de nombres actual
      es <literal>espacedenomscourant</literal>, esto se resuelve en
      <literal>espacedenomscourant\foo</literal>. Si el espacio de nombres es
      global, es decir, el espacio de nombres sin nombre, esto se convierte en <literal>foo</literal>.
     </simpara>
     <simpara>
      Una advertencia: los nombres sin calificativo para las funciones y las
      constantes se tomarán del espacio de nombres global, si la función
      no está definida en el espacio de nombres actual. Véase
      <link linkend="language.namespaces.fallback">Uso de los espacios de nombres:
      retorno al espacio de nombres global para las funciones y las constantes</link> para
      más detalles.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Un nombre calificado, o una clase prefijada como
      <literal>$a = new subespacedenoms\foo();</literal> o
      <literal>subespacedenoms\foo::methodestatique();</literal>. Si el espacio de nombres actual
      es <literal>espacedenomscourant</literal>, esto se convierte
      en <literal>espacedenomscourant\subespacedenoms\foo</literal>. Si
      el código es global, es decir, el espacio de nombres sin nombre,
      esto se convierte en <literal>subespacedenoms\foo</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Un nombre absoluto, o un nombre prefijado con un operador global como
      <literal>$a = new \espacedenomscourant\foo();</literal> o
      <literal>\espacedenomscourant\foo::methodestatique();</literal>. Esto siempre
      hace referencia al nombre literal especificado en el código: <literal>espacedenomscourant\foo</literal>.
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <para>
   A continuación se muestra un ejemplo de las tres sintaxis, en código real:
   <informalexample>
    <simpara>file1.php</simpara>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Foo\Bar\subespacio_de_nombres;

const FOO = 1;
function foo() {}
class foo
{
    static function método_estático() {}
}
?>
     ]]>
    </programlisting>
    <simpara>file2.php</simpara>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Foo\Bar;
include 'fichero1.php';

const FOO = 2;
function foo() {}
class foo
{
    static function método_estático() {}
}

/* Nombre no cualificado */
foo(); // se resuelve con la función Foo\Bar\foo
foo::método_estático(); // se resuelve con la clase Foo\Bar\foo, método método_estático
echo FOO; // se resuelve con la constante Foo\Bar\FOO

/* Nombre cualificado */
subespacio_de_nombres\foo(); // se resuelve con la función Foo\Bar\subespacio_de_nombres\foo
subespacio_de_nombres\foo::método_estático(); // se resuelve con la clase Foo\Bar\subespacio_de_nombres\foo,
                                              // método método_estático
echo subespacio_de_nombres\FOO; // se resuelve con la constante Foo\Bar\subespacio_de_nombres\FOO

/* Nombre conmpletamente cualificado */
\Foo\Bar\foo(); // se resuelve con la función Foo\Bar\foo
\Foo\Bar\foo::método_estático(); // se resuelve con la clase Foo\Bar\foo, método método_estático
echo \Foo\Bar\FOO; // se resuelve con la constante Foo\Bar\FOO
?>
     ]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   Tenga en cuenta que para acceder a cualquier clase, función o constante
   global, se puede utilizar un nombre absoluto, como
   <function>\strlen</function> o <classname>\Exception</classname> o
   \<constant>INI_ALL</constant>.
   <example>
    <title>Acceso a las clases, funciones y constantes globales desde un espacio de nombres</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Foo;

function strlen() {}
const INI_ALL = 3;
class Exception {}

$a = \strlen('hola'); // llama a la función global strlen
$b = \INI_ALL; // accede a la constante global INI_ALL
$c = new \Exception('error'); // instancia a la clase global Exception
?>
     ]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.dynamic">
  <title>Espacios de nombres y lenguaje dinámico</title>
  <titleabbrev>Espacios de nombres y lenguaje dinámico</titleabbrev>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   La implementación de los espacios de nombres de PHP está influenciada por su naturaleza dinámica
   de lenguaje de programación. Por lo tanto, para convertir el código como el del ejemplo siguiente,
   en un espacio de nombres:
   <example>
    <title>Acceso dinámico a los elementos</title>
    <simpara>example1.php:</simpara>
    <programlisting role="php">
     <![CDATA[
<?php
class nombre_clase
{
    function __construct()
    {
        echo __METHOD__,"\n";
    }
}
function nombre_func()
{
    echo __FUNCTION__,"\n";
}
const nombre_const = "global";

$a = 'nombre_clase';
$obj = new $a; // imprime nombre_clase::__construct
$b = 'nombre_func';
$b(); // imprime nombre_func
echo constant('nombre_const'), "\n"; // imprime global
?>
    ]]>
    </programlisting>
   </example>
   Es necesario utilizar un nombre absoluto (el nombre de la clase, con su prefijo de espacio
   de nombres). Tenga en cuenta que no hay diferencia entre un nombre absoluto y un nombre calificado
   en un nombre de clase, función o constante dinámica, lo que hace que el antislash
   inicial no sea necesario.
   <example>
    <title>Acceso dinámico a los espacios de nombres</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace nombre_espacio_de_nombres;
class nombre_clase
{
    function __construct()
    {
        echo __METHOD__,"\n";
    }
}
function nombre_func()
{
    echo __FUNCTION__,"\n";
}
const nombre_const = "de espacio de nombres";

/* observe que si se emplean comillas dobles, se debe usar "\\nombre_espacio_de_nombres\\nombre_clase" */
$a = '\nombre_espacio_de_nombres\nombre_clase';
$obj = new $a; // imprime nombre_espacio_de_nombres\nombre_clase::__construct
$a = 'nombre_espacio_de_nombres\nombre_clase';
$obj = new $a; // también imprime nombre_espacio_de_nombres\nombre_clase::__construct
$b = 'nombre_espacio_de_nombres\nombre_func';
$b(); // imprime nombre_espacio_de_nombres\nombre_func
$b = '\nombre_espacio_de_nombres\nombre_func';
$b(); // también imprime nombre_espacio_de_nombres\nombre_func
echo constant('\nombre_espacio_de_nombres\nombre_const'), "\n"; // imprime de espacio de nombres
echo constant('nombre_espacio_de_nombres\nombre_const'), "\n"; // también imprime de espacio de nombres
?>
    ]]>
    </programlisting>
   </example>
  </para>
  <para>
   Se recomienda leer la <link linkend="language.namespaces.faq.quote">nota sobre la protección de los espacios de nombres en las cadenas</link>.
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.nsconstants">
  <title>El comando namespace y la constante __NAMESPACE__</title>
  <titleabbrev>Comando namespace y __NAMESPACE__</titleabbrev>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   PHP soporta dos medios para acceder de manera abstracta a los elementos
   en el espacio de nombres actual, a saber, la constante mágica
   <constant>__NAMESPACE__</constant> y el comando <literal>namespace</literal>.
  </para>
  <para>
   El valor de <constant>__NAMESPACE__</constant> es una cadena que contiene el nombre
   del espacio de nombres actual. En el espacio global, sin nombre, contiene
   una cadena vacía.
   <example>
    <title>Ejemplo con __NAMESPACE__, en un código con espacio de nombres</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MiProyecto;

echo '"', __NAMESPACE__, '"'; // imprime "MiProyecto"
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>Ejemplo con __NAMESPACE__, en un código con espacio de nombres global</title>
    <programlisting role="php">
     <![CDATA[
<?php

echo '"', __NAMESPACE__, '"'; // muestra ""
?>
]]>
    </programlisting>
   </example>
   La constante <constant>__NAMESPACE__</constant> es útil para construir
   dinámicamente nombres, como:
   <example>
    <title>Uso de __NAMESPACE__ para una construcción dinámica de nombres</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MiProyecto;

function obtener($nombre_clase)
{
    $a = __NAMESPACE__ . '\\' . $nombre_clase;
    return new $a;
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   El comando <literal>namespace</literal> también puede ser utilizado para
   solicitar explícitamente un elemento del espacio de nombres actual, o de un
   subespacio. Es el equivalente para los espacios de nombres del operador
   <literal>self</literal> de las clases.
   <example>
    <title>El operador namespace, en un espacio de nombres</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MiProyecto;

use blah\blah as mío; // véase "Uso de los espacios de nombres: Apodar/Importar"

blah\mío(); // llama a la función MiProyecto\blah\mío()
namespace\blah\mío(); // llama a la función MiProyecto\blah\mío()

namespace\func(); // llama a la función MiProyecto\func()
namespace\sub\func(); // llama a la función MiProyecto\sub\func()
namespace\nombrec::método(); // llama al método estático "método" de la clase MiProyecto\nombrec
$a = new namespace\sub\nombrec(); // instancia un objeto de la clase MiProyecto\sub\nombrec
$b = namespace\CONSTANTE; // asigna el valor de la constante MiProyecto\CONSTANTE a $b
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>El operador namespace, en el espacio de nombres global</title>
    <programlisting role="php">
     <![CDATA[
<?php

namespace\func(); // llama a la función func()
namespace\sub\func(); // llama a la función sub\func()
namespace\nombrec::método(); // llama al método estático "método" de la clase nombrec
$a = new namespace\sub\nombrec(); // instancia un objeto de la clase sub\nombrec
$b = namespace\CONSTANTE; // asigna el valor de la constante CONSTANTE a $b
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.importing">
  <?phpdoc print-version-for="namespaces"?>
  <title>Uso de los espacios de nombres: importación y alias</title>
  <titleabbrev>Importación y alias</titleabbrev>
  <para>
   La capacidad de hacer referencia a un nombre absoluto con un alias o importando
   un espacio de nombres es estratégica. Es un beneficio similar a los enlaces
   simbólicos en un sistema de ficheros.
  </para>
  <para>
   PHP puede aliasar(/importar) las constantes, funciones, clases, interfaces,
   traits, enumeraciones y los espacios de nombres.
  </para>
  <para>
   Un alias se crea con el operador <literal>use</literal>.
   A continuación se muestra un ejemplo que presenta los cinco tipos de importación:
   <example>
    <title>Importación y alias con el operador use</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace foo;
use Mi\Completo\NombreDeClase as Otra;

// esto es lo mismo que utilizar Mi\Completo\NombreEN as NombreEN
use Mi\Completo\NombreEN;

// importar una clase global
use ArrayObject;

// importar una función (PHP 5.6+)
use function Mi\Completo\nombreDeFunción;

// apodar una función (PHP 5.6+)
use function Mi\Completo\nombreDeFunción as func;

// importar una constante (PHP 5.6+)
use const Mi\Completa\CONSTANTE;

$obj = new namespace\Otra; // instancia un objeto de la clase foo\Otra
$obj = new Otra; // instancia un objeto de la clase class Mi\Completo\NombreDeClase
NombreEN\suben\func(); // llama a la función Mi\Completo\NombreEN\subes\func
$a = new ArrayObject(array(1)); // instancia un objeto de la clase ArrayObject
// sin el "use ArrayObject" instanciaríamos un objeto de la clase foo\ArrayObject
func(); // llama a la función Mi\Completo\nombreDeFunción
echo CONSTANT; // imprime el valor de Mi\Completa\CONSTANTE;
?>
]]>
    </programlisting>
   </example>
   Tenga en cuenta que para los nombres con ruta (los nombres absolutos que contienen
   separadores de espacios, como <literal>Foo\Bar</literal>, en comparación con
   los nombres globales, como <literal>FooBar</literal>, que no los contienen), el antislash
   inicial no es necesario y no es recomendado, ya que los nombres importados
   deben ser absolutos y no se resuelven relativamente al espacio de nombres actual.
  </para>
  <para>
   Además, PHP soporta atajos prácticos, como las instrucciones use múltiples.
   <example>
    <title>Importación y alias múltiples con el operador use</title>
    <programlisting role="php">
     <![CDATA[
<?php
use Mi\Completo\NombreDeClase as Otra, Mi\Completo\NombreEN;

$obj = new Otra; // instancia un objeto de la clase Mi\Completo\NombreDeClase
NombreEN\suben\func(); // llama a la función Mi\Completo\NombreEN\suben\func
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   La importación se realiza durante la compilación, lo que hace que no afecte
   a las clases, funciones y constantes dinámicas.
   <example>
    <title>Importación y nombres de espacios dinámicos</title>
    <programlisting role="php">
     <![CDATA[
<?php
use Mi\Completo\NombreDeClase as Otra, Mi\Completo\NombreEN;

$obj = new Otra; // instancia un objeto de la clase Mi\Completo\NombreDeClase
$a = 'Otra';
$obj = new $a;   // instancia un objeto de la clase Otra
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Además, la importación solo afecta a los nombres sin calificación. Los nombres
   absolutos permanecen absolutos e inalterados por una importación.
   <example>
    <title>Importación y nombres de espacios absolutos</title>
    <programlisting role="php">
     <![CDATA[
<?php
use Mi\Completo\NombreDeClase as Otra, Mi\Completo\NombreEN;

$obj = new Otra; // instancia un objeto de la clase Mi\Completo\NombreDeClase
$obj = new \Otra; // instancia un objeto de la clase Otra
$obj = new Otra\cosa; // instancia un objeto de la clase Mi\Completo\NombreDeClase\cosa
$obj = new \Otra\cosa; // instancia un objeto de la clase Otra\cosa
?>
]]>
    </programlisting>
   </example>
  </para>
  <sect2 xml:id="language.namespaces.importing.scope">
   <title>Reglas de contexto para la importación</title>
   <para>
    La palabra clave <literal>use</literal> debe ser declarada en el contexto más
    externo de un fichero (el contexto global) o en las declaraciones de espacio
    de nombres. Esto se debe a que la importación se realiza durante la compilación y no durante
    la ejecución, por lo que no se pueden apilar los contextos. El ejemplo siguiente muestra
    usos incorrectos de la palabra clave <literal>use</literal>:
   </para>
   <para>
    <example>
     <title>Reglas de importación incorrectas</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace Idiomas;

function aGroenlandés
{
    use Idiomas\Danés;

    // ...
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Las reglas de importación se basan en los ficheros, lo que significa que los ficheros
     incluidos no heredarán <emphasis>PAS</emphasis> las reglas de importación del fichero padre.
    </para>
   </note>
  </sect2>
  <sect2 xml:id="language.namespaces.importing.group">
   <title>Declaración del grupo <literal>use</literal></title>
   <para>
    Las clases, funciones y constantes importadas desde
    el mismo &namespace; pueden ser agrupadas en una
    sola instrucción &use.namespace;.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php

// Código anterir a PHP 7
use un\espacioDeNombres\ClaseA;
use un\espacioDeNombres\ClaseB;
use un\espacioDeNombres\ClaseC as C;

use function un\espacioDeNombres\fn_a;
use function un\espacioDeNombres\fn_b;
use function un\espacioDeNombres\fn_c;

use const un\espacioDeNombres\ConstA;
use const un\espacioDeNombres\ConstB;
use const un\espacioDeNombres\ConstC;

// Código de PHP 7+
use un\espacioDeNombres\{ClaseA, ClaseB, ClaseC as C};
use function un\espacioDeNombres\{fn_a, fn_b, fn_c};
use const un\espacioDeNombres\{ConstA, ConstB, ConstC};
]]>
    </programlisting>
   </informalexample>
  </sect2>

 </sect1>
 <sect1 xml:id="language.namespaces.global">
  <title>Espacio de nombres global</title>
  <titleabbrev>Global</titleabbrev>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Sin ninguna definición de espacio de nombres, todas las clases y las funciones
   se colocan en el espacio de nombres global: como en PHP antes de que los espacios
   de nombres fueran introducidos. Prefijando un nombre con un antislash
   <literal>\</literal>, se puede solicitar el uso del espacio de nombres
   global, incluso en un contexto de espacio de nombres específico.
   <example>
    <title>Especificación de espacio de nombres global</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace A\B\C;

/* Esta función es A\B\C\fopen */
function fopen() {
     /* ... */
     $f = \fopen(...); // llamar a fopen global
     return $f;
}
?>
    ]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.fallback">
  <title>Uso de los espacios de nombres: retorno al espacio global para las funciones y las constantes</title>
  <titleabbrev>Retorno al espacio global</titleabbrev>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   En un espacio de nombres, cuando PHP encuentra un nombre sin calificación,
   ya sea una clase, una función o una constante, lo resuelve con diferentes
   prioridades. Los nombres de clases siempre se resuelven con el espacio de nombres actual.
   Para acceder a clases internas o a clases que no están en
   un espacio de nombres, es necesario representarlas con su nombre absoluto, como:
   <example>
    <title>Acceso a las clases globales desde un espacio de nombres</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace A\B\C;
class Exception extends \Exception {}

$a = new Exception('hola'); // $a es un objeto de la clase A\B\C\Exception
$b = new \Exception('hola'); // $b es un objeto de la clase Exception

$c = new ArrayObject; // error fatal, no se encontró la clase A\B\C\ArrayObject
?>
    ]]>
    </programlisting>
   </example>
  </para>
  <para>
   Para las funciones y constantes, PHP irá a buscarlas en el espacio
   global si no puede encontrarlas en el espacio de nombres actual.
   <example>
    <title>Acceso a las funciones y constantes globales en un espacio de nombres</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace A\B\C;

const E_ERROR = 45;
function strlen($str)
{
    return \strlen($str) - 1;
}

echo E_ERROR, "\n"; // imprime "45"
echo INI_ALL, "\n"; // imprime "7" - recurre a INI_ALL global

echo strlen('hola'), "\n"; // imprime "3"
if (is_array('hola')) { // imprime "no es un array"
    echo "es una array\n";
} else {
    echo "no es un array\n";
}
?>
    ]]>
    </programlisting>
   </example>
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.rules">
  <title>Reglas de resolución de nombres</title>
  <titleabbrev>Reglas de resolución de nombres</titleabbrev>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   En el marco de las reglas de resolución, hay varias definiciones importantes:
   <variablelist>
    <title>Definiciones para los espacios de nombres</title>
    <varlistentry>
     <term>nombre no calificado</term>
     <listitem>
      <para>
       Esto es un identificador que no contiene un separador de espacio de nombres.
       Por ejemplo: <literal>Foo</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>nombre calificado</term>
     <listitem>
      <para>
       Esto es un identificador que contiene un separador de espacio de nombres.
       Por ejemplo: <literal>Foo\Bar</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Nombre absoluto</term>
     <listitem>
      <para>
       Esto es un identificador que comienza con un separador de espacio de nombres.
       Por ejemplo: <literal>\Foo\Bar</literal>. El espacio de nombres <literal>Foo</literal>
       también es un nombre absoluto.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Nombre relativo</term>
     <listitem>
      <para>
       Esto es un identificador que comienza con <literal>namespace</literal>, como
       <literal>namespace\Foo\Bar</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  <para>
   Los nombres se resuelven siguiendo las siguientes reglas:
   <orderedlist>
    <listitem>
     <simpara>
      Los nombres absolutos siempre se traducen por los nombres sin el separador de namespace.
      Por ejemplo, <literal>\A\B</literal> se traduce por <literal>A\B</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Todos los nombres que no son absolutos se traducen con
       el <literal>namespace</literal> reemplazado por el namespace actual.
      Si el nombre aparece en el namespace global, el prefijo
      <literal>namespace\</literal> se elimina. Por ejemplo  <literal>namespace\A</literal>
      en el namespace <literal>X\Y</literal> se traduce por <literal>X\Y\A</literal>.
      El mismo nombre en el namespace global se traduce por <literal>A</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Para los nombres absolutos, el primer segmento se traduce
      de acuerdo con la class/namespace de la tabla de importación.
      Por ejemplo, si el namespace <literal>A\B\C</literal> se importa como <literal>C</literal>, el nombre <literal>C\D\E</literal> se traduce por <literal>A\B\C\D\E</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Para los nombres absolutos, si ninguna regla de importación
      se aplica, el namespace actual se prefiere al nombre.
      Por ejemplo, el nombre <literal>C\D\E</literal> en el namespace <literal>A\B</literal>,
      se traduce por <literal>A\B\C\D\E</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Para los nombres absolutos, el nombre se traduce en relación con la tabla de importación actual para el tipo de símbolo respectivo.
      Esto significa que un nombre que se asemeja a una clase se traduce de acuerdo con la tabla de importación de
      class/namespace, los nombres de funciones utilizando la
      tabla de importación de funciones, y las constantes utilizando la tabla de importación de constantes.
      Por ejemplo, después
      <literal>use A\B\C;</literal> un uso como <literal>new C()</literal> corresponde al nombre
      <literal>A\B\C()</literal>. De la misma manera, después <literal>use function A\B\foo;</literal> un uso
      como <literal>foo()</literal> corresponde al nombre <literal>A\B\foo</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Para los nombres relativos, si ninguna regla se aplica, y que el nombre
      hace referencia a una clase, el namespace actual sirve de prefijo.
      Por ejemplo <literal>new C()</literal> en el namespace
      <literal>A\B</literal> corresponde al nombre <literal>A\B\C</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      para los nombres relativos, si ninguna regla se aplica, y que el nombre
      hace referencia a una función o una constante, y que el código está fuera
      del namespace global, el nombre se resuelve por la ejecución.
      Supongamos que el código está en el namespace
      <literal>A\B</literal>, aquí es cómo se resuelve una llamada a la función <literal>foo()</literal>:
     </simpara>

     <orderedlist>
      <listitem>
       <simpara>
        Busca una función en el espacio de nombres actual:
        <literal>A\B\foo()</literal>.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Intenta encontrar y llamar a la función <emphasis>global</emphasis>
        <literal>foo()</literal>.
       </simpara>
      </listitem>
     </orderedlist>
    </listitem>
   </orderedlist>
  </para>
  <example>
   <title>Ejemplos de resolución de espacios de nombres</title>
   <programlisting role="php">
<![CDATA[
<?php
namespace A;
use B\D, C\E as F;

// llamadas a funciones

foo();      // primero se intenta llamar a "foo" definida en el espacio de nombres "A"
            // después se llama a la función global "foo"

\foo();     // se llama a la función "foo" definidia en el ámbito global

mi\foo();   // se llama a la función "foo" definida en el espacio de nombres "A\mi"

F();        // primero se intenta llamar a "F" definida en el espacio de nombres "A"
            // después se llama a la función global "F"

// referecias a clases

new B();    // crea un objeto de la clase "B" definida en el espacio de nombres "A"
            // si no se encuentra, se intenta autocargar la clase "A\B"

new D();    // usando las reglas de importación, se crea un objeto de la clase "D" definida en el espacio de nombres "B"
            // si no se encuentra, se intenta autocargar la clase "B\D"

new F();    // usando las reglas de importación, se crea un objeto de la clase "E" definida en el espacio de nombres "C"
            // si no se encuentra, se intenta autocargar la clase "C\E"

new \B();   // crea un objeto de la clase "B" definida en el ámbito global
            // si no se encuentra, se intenta autocargar la clase "B"

new \D();   // crea un objeto de la clase "D" definida en el ámbito global
            // si no se encuentra, se intenta autocargar la clase "D"

new \F();   // crea un objeto de la clase "F" definida en el ámbito global
            // si no se encuentra, se intenta autocargar la clase "F"

// métodos estáticos y funciones de un espacio de nombres desde otro espacio de nombres

B\foo();    // se llama a la función "foo" desde el espacio de nombres "A\B"

B::foo();   // se llama al método "foo" de la clase "B" definidia en el espacio de nombres "A"
            // si no se encuentra la clase "A\B", se intenta autocargar la clase "A\B"

D::foo();   // usando las reglas de importación, se llama al método "foo" de la clase "D" definida en el espacio de nombres "B"
            // si no se encuentra la clase "B\D", se intenta autocargar la clase "B\D"

\B\foo();   // se llama a la función "foo" desde el espacio de nombres "B"

\B::foo();  // se llama al método "foo" de la clase "B" desde el ámbito global
            // si no es encuentra la clase "B", se intenta autocargar la clase "B"

// métodos estáticos y funciones de espacio de nombres del espacio actual

A\B::foo();   // llama al método "foo" de la clase "B" del espacio de nombres "A\A"
              // si la clase "A\A\B" no se encuentra, intenta la carga automática en la clase "A\A\B"

\A\B::foo();  // llama al método "foo" de la clase "B" del espacio de nombres "A"
              // si la clase "A\B" no se encuentra, intenta la carga automática en la clase "A\B"
?>
]]>
   </programlisting>
  </example>
 </sect1>
 <sect1 xml:id="language.namespaces.faq">
  <title>Preguntas frecuentes: lo que debe saber sobre los espacios de nombres</title>
  <titleabbrev>Preguntas frecuentes</titleabbrev>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Esta FAQ se desglosa en dos secciones: las preguntas frecuentes,
   y los puntos particulares de la implementación, que pueden ser
   útiles para la comprensión global.
  </para>
  <para>
   Primero, las preguntas frecuentes.
   <orderedlist>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.shouldicare">Si no se utilizan espacios
      de nombres, ¿debo preocuparme por ellos?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.globalclass">¿Cómo utilizar una clase
      global o interna desde un espacio de nombres?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.innamespace">¿Cómo utilizar las clases
      de espacios de nombres, las funciones o las constantes en su propio espacio?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.full">
       ¿Cómo se resuelve un nombre como <literal>\mon\nom</literal> o
       <literal>\nom</literal>?
      </link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.qualified">¿Cómo se resuelve un nombre
      como <literal>mon\nom</literal>?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.shortname1">¿Cómo se resuelve un nombre de clase
      sin calificación, como <literal>nom</literal>?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.shortname2">¿Cómo se resuelve una función sin
      calificación o una constante de nombre <literal>nom</literal>?</link>
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <para>
   A continuación se muestran los puntos particulares de la implementación, que pueden ser
   útiles para la comprensión global.
   <orderedlist>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.conflict">Los nombres importados no deben
      entrar en conflicto con las clases definidas en el mismo fichero</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.nested">Los espacios de nombres anidados
      están prohibidos</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.quote">Los nombres de espacios de nombres
      dinámicos deben proteger el antislash</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.constants">Las constantes indefinidas
      referenciadas con un antislash producen un error fatal</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.builtinconst">Imposible reemplazar
      constantes especiales como &null;, &true; o &false;</link>
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <sect2 xml:id="language.namespaces.faq.shouldicare">
   <title>Si no se utilizan espacios de nombres, ¿debo preocuparme por ellos?</title>
   <para>
    No, los espacios de nombres no afectan el código existente, de una
    manera u otra, ni el código que se producirá y que no utiliza
    los espacios de nombres. Se puede escribir esto si se desea:
   </para>
   <para>
    <example>
     <title>Acceso a una clase global desde fuera de un espacio de nombres</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = new \stdClass;
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Es una funcionalidad equivalente a:
   </para>
   <para>
    <example>
     <title>Acceder a clases globales fuera de un espacio de nombres</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = new stdClass;
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.globalclass">
   <title>¿Cómo utilizar una clase global o interna desde un espacio de nombres?</title>
   <para>
    <example>
     <title>Acceso a las clases internas desde un espacio de nombres</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;
$a = new \stdClass;

function probar(\ArrayObject $ejemploalusiónatipo = null) {}

$a = \DirectoryIterator::CURRENT_AS_FILEINFO;

// extender una clase interna o global
class MiExcepción extends \Exception {}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.innamespace">
   <title>
    ¿Cómo utilizar las clases de espacios de nombres, las funciones o
    las constantes en su propio espacio?
   </title>
   <para>
    <example>
     <title>Acceso a las clases, funciones y constantes internas en un espacio de nombres</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;

class MiClase {}

// usar una clase desde el espacio de nombres actual como una declaración de tipo
function probar(MiClase $ejemploalusiónatipo = null) {}
// otra manera de usar una clase desde el espacio de nombres actual una declaración de tipo
function probar(\foo\MiClase $ejemploalusiónatipo = null) {}

// extender una clase desde el espacio de nombres actual
class Extendida extends MiClase {}

// acceder a una función global
$a = \funcglobal();

// acceder a una constante global
$b = \INI_ALL;
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.full">
   <title>
     ¿Cómo se resuelve un nombre como <literal>\mon\nom</literal> o
       <literal>\nom</literal>?
   </title>
   <para>
    Los nombres que comienzan con <literal>\</literal> siempre se resuelven en lo
    que parecen, por lo que <literal>\mon\nom</literal> es en realidad
    <literal>mon\nom</literal>, y <literal>\Exception</literal> es
    <literal>Exception</literal>.
    <example>
     <title>Nombres de espacios absolutos</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;
$a = new \mi\nombre(); // instancia a la clase "mi\nombre"
echo \strlen('hola'); // llama a la función "strlen"
$a = \INI_ALL; // $a está establecida al valor de la constante "INI_ALL"
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.qualified">
   <title>¿Cómo se resuelve un nombre como <literal>mon\nom</literal>?</title>
   <para>
    Los nombres que contienen un antislash pero no comienzan con un
    antislash, como <literal>mon\nom</literal> pueden ser resueltos de dos maneras
    diferentes.
   </para>
   <para>
    Si ha habido una instrucción de importación que hace un alias de
    <literal>mon</literal>, entonces el alias importado se aplica en lugar
    de <literal>mon</literal>, y el espacio de nombres se convierte en <literal>mon\nom</literal>.
   </para>
   <para>
    De lo contrario, el espacio de nombres actual se añade antes del camino de la clase
    <literal>mon\nom</literal>.
   </para>
   <para>
    <example>
     <title>Nombres calificados</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;
use blah\blah as foo;

$a = new mi\nombre(); // instancia a la clase "foo\mi\nombre"
foo\bar::nombre(); // llama a método estático "nombre" de la clase "blah\blah\bar"
mi\bar(); // llama a la función "foo\mi\bar"
$a = mi\BAR; // establece $a al valor de la constante "foo\mi\BAR"
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.shortname1">
   <title>¿Cómo se resuelve un nombre de clase
    sin calificación, como <literal>nom</literal>?</title>
   <para>
    Los nombres de clases que no contienen un antislash como
    <literal>nom</literal> pueden ser resueltos de dos maneras diferentes.
   </para>
   <para>
    Si hay una instrucción de importación que define un alias para <literal>nom</literal>,
    entonces el alias se aplica.
   </para>
   <para>
    De lo contrario, el espacio de nombres actual se utiliza y se prefiere a
    <literal>nom</literal>.
   </para>
   <para>
    <example>
     <title>Clases sin calificación</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;
use blah\blah as foo;

$a = new nom(); // instancia la clase "foo\nom"
foo::nom(); // llama al método estático "nom" en la clase "blah\blah"
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.shortname2">
   <title>
    ¿Cómo se resuelve una función sin calificación o una constante
    de nombre <literal>nom</literal>?
   </title>
   <para>
    Las funciones y constantes que no tienen un antislash en su nombre
    como <literal>nom</literal> se resuelven de dos maneras diferentes:
   </para>
   <para>
    Primero, el espacio de nombres actual se prefiere a <literal>nom</literal>.
   </para>
   <para>
    Luego, si la constante o la función <literal>nom</literal> no existe
    en el espacio de nombres actual, se utiliza la versión global de la constante o la
    función <literal>nom</literal>.
   </para>
   <para>
    <example>
     <title>Funciones y constantes sin espacio de nombres</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;
use blah\blah as foo;

const FOO = 1;

function mi() {}
function foo() {}
function sort(&$a)
{
    \sort($a); // invoca a la función global "sort"
    $a = array_flip($a);
    return $a;
}

mi(); // calls "foo\mi"
$a = strlen('hola'); // llama a la función global "strlen" ya que "foo\strlen" no existe
$array = array(1,3,2);
$b = sort($array); // llama a la función "foo\sort"
$c = foo(); // llama a la función "foo\foo" - la importación no se aplica

$a = FOO; // establece $a al valor de la constante "foo\FOO"; la importación no se aplica
$b = INI_ALL; // establece $b al valor de la constante "INI_ALL"
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.conflict">
   <title>Los nombres importados no deben
    entrar en conflicto con las clases definidas en el mismo fichero</title>
   <para>
    La combinación de scripts siguiente es válida:
    <informalexample>
     <simpara>file1.php</simpara>
     <programlisting role="php">
     <![CDATA[
<?php
namespace mis\cosas;
class MiClase {}
?>
     ]]>
     </programlisting>
     <simpara>another.php</simpara>
     <programlisting role="php">
     <![CDATA[
<?php
namespace otro;
class cosa {}
?>
     ]]>
     </programlisting>
     <simpara>file2.php</simpara>
     <programlisting role="php">
     <![CDATA[
<?php
namespace mis\cosas;
include 'fichero1.php';
include 'otro.php';

use otro\cosa as MiClase;
$a = new MiClase; // instancia a la clase "cosa" del espacio de nombres otro
?>
     ]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    No hay conflicto de nombres, aunque la clase <literal>MiClase</literal> existe
    en el espacio de nombres <literal>mes\trucs</literal>, ya que la definición de
    <literal>MiClase</literal> está en un fichero separado. Sin embargo, el ejemplo
    siguiente produce un error fatal debido a un conflicto de nombres, ya que
    <literal>MiClase</literal> está definida en el mismo fichero que la instrucción
    <literal>use</literal>.
    <informalexample>
     <programlisting role="php">
     <![CDATA[
<?php
namespace mis\cosas;
use otro\cosa as MiClase;
class MiClase {} // error fatal: MiClase entra en conflicto con la sentencia de importación
$a = new MiClase;
?>
     ]]>
     </programlisting>
    </informalexample>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.nested">
   <title>Los espacios de nombres anidados están prohibidos</title>
   <para>
    PHP no permite anidar espacios de nombres.
    <informalexample>
     <programlisting role="php">
     <![CDATA[
<?php
namespace mis\cosas {
    namespace anidado {
        class foo {}
    }
}
?>
     ]]>
     </programlisting>
    </informalexample>
    Sin embargo, es fácil simular espacios de nombres anidados,
    como esto:
    <informalexample>
     <programlisting role="php">
     <![CDATA[
<?php
namespace mis\cosas\anidado {
    class foo {}
}
?>
     ]]>
     </programlisting>
    </informalexample>
   </para>
  </sect2>

  <sect2 xml:id="language.namespaces.faq.quote">
   <title>Los nombres de espacios de nombres dinámicos deben proteger el antislash</title>
   <para>
    Es muy importante tener en cuenta que, como los antislash se utilizan como
    caracteres de protección en las cadenas, siempre deben ser duplicados
    para poder ser utilizados en una cadena. De lo contrario, existe el riesgo de uso
    inesperado:
    <example>
     <title>Peligros del uso de los espacios de nombres en una cadena</title>
     <programlisting role="php">
      <![CDATA[
<?php
$a = "peligroso\nombre"; // ¡\n es una nueva línea dentro de las cadenas entre comillas dobles!
$obj = new $a;

$a = 'sin\peligro\alguno'; // aquí sin problemas.
$obj = new $a;
?>
      ]]>
     </programlisting>
    </example>
    En una cadena con comillas dobles, la secuencia de protección es mucho más
    segura de usar, pero aún así se recomienda proteger siempre los antislashs en una cadena que contiene un espacio de nombres.
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.constants">
   <title>Las constantes indefinidas referenciadas con un antislash producen un error fatal</title>
   <para>
    Toda constante indefinida que no esté calificada, como
    <literal>FOO</literal> producirá una advertencia: PHP suponía que
    <literal>FOO</literal> era el valor de la constante. Toda constante,
    calificada parcialmente o totalmente, que contenga un antislash, producirá un error fatal si está indefinida.
    <example>
     <title>Constantes indefinidas</title>
     <programlisting role="php">
      <![CDATA[
<?php
namespace bar;
$a = FOO; // produce un aviso - constante no definida "FOO" se asume que es "FOO";
$a = \FOO; // error fatal, constante FOO del espacio de nombres no definida
$a = Bar\FOO; // error fatal, constante bar\Bar\FOO del espacio de nombres no definida
$a = \Bar\FOO; // error fatal, constante Bar\FOO del espacio de nombres no definida
?>
      ]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.builtinconst">
   <title>Imposible reemplazar constantes especiales como &null;, &true; o &false;</title>
   <para>
    Todo intento en un espacio de nombres de reemplazar las constantes
    nativas o especiales, produce un error fatal.
    <example>
     <title>Constantes que no pueden ser redefinidas</title>
     <programlisting role="php">
      <![CDATA[
<?php
namespace bar;
const NULL = 0; // error fatal;
const true = 'estúpido'; // también error fatal;
// etc.
?>
      ]]>
     </programlisting>
    </example>
   </para>
  </sect2>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
