<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: b8f3ae7da35b99b3137ff59aa5d86110dde607f4 Maintainer: PhilDaiguille Status: ready -->
<!-- Reviewed: no -->
<chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
 <title>Las funciones</title>

 <sect1 xml:id="functions.user-defined">
  <title>Las funciones definidas por el usuario</title>

  <para>
   Una función se define utilizando la palabra clave <literal>function</literal>,
   un nombre, una lista de parámetros (que pueden estar vacíos) separados por comas
   (<literal>,</literal>) entre paréntesis, seguidos del cuerpo de
   la función entre llaves, como sigue:
  </para>
  <example>
   <title>Declaración de una nueva función llamada <literal>foo</literal></title>
   <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Ejemplo de función.\n";
    return $retval;
}
?>
]]>
   </programlisting>
  </example>
  <note>
   <para>
    A partir de PHP 8.0.0, la lista de parámetros puede tener una coma final:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2,) { }
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </note>

  <simpara>
   Cualquier código PHP válido puede aparecer dentro del cuerpo de una función, incluso otras
   dentro de una función y en las definiciones de
   <link linkend="language.oop5.basic.class">clase</link>.
  </simpara>
  <para>
   Los nombres de funciones siguen las mismas reglas que otros labels en PHP.
   Un nombre de función válido comienza por una letra o un guion bajo, seguido
   por un número cualquiera de letras, números o guiones bajos.
   Estas reglas pueden ser representadas por la siguiente expresión regular:
   <code>^[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*$</code>
  </para>
  &tip.userlandnaming;
  <simpara>
   Las funciones no necesitan ser definidas antes de ser utilizadas,
   <emphasis>EXCEPTO</emphasis> cuando una función es definida
   condicionalmente, como se muestra en los dos ejemplos siguientes.
  </simpara>
  <para>
   Cuando una función es definida de manera condicional, como en
   los ejemplos a continuación, su definición debe <emphasis>preceder</emphasis>
   su uso.
  </para>
  <para>
   <example>
    <title>Funciones condicionales</title>
    <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* No se puede llamar a foo() aquí,
   porque esta función no existe.
   Pero se puede usar bar() */

bar();

if ($makefoo) {
  function foo()
  {
    echo "No existo hasta que el programa no pase por aquí.\n";
  }
}

/* Ahora se puede llamar a foo()
   porque $makefoo es evaluado como verdadero */

if ($makefoo) foo();

function bar()
{
  echo "Existo desde el inicio del programa.\n";
}

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Funciones dentro de otra función</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "No existo hasta que foo() no sea llamado.\n";
  }
}

/* No se puede llamar a bar() aquí
   porque no existe. */

foo();

/* Ahora se puede llamar a bar(),
   porque el uso de foo() la ha hecho
   accesible. */

bar();

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Todas las funciones y clases en PHP tienen un ámbito global - pueden ser llamadas fuera de una función si han sido definidas
   dentro y viceversa.
  </para>
  <simpara>
   PHP no soporta la sobrecarga, la destrucción y la redefinición de
   funciones ya declaradas.
  </simpara>
  <note>
   <simpara>
    Los nombres de funciones no distinguen entre mayúsculas y minúsculas para los caracteres ASCII
    <literal>A</literal> a <literal>Z</literal>,
    y generalmente se acepta que las funciones deben
    ser llamadas con el nombre utilizado en su declaración,
    incluyendo la capitalización.
   </simpara>
  </note>
  <simpara>
   Las <link linkend="functions.variable-arg-list">
   listas variables de argumentos de función</link> y las
   <link linkend="functions.arguments.default">valores por defecto
    de argumentos</link> son soportados: ver
   las funciones de referencia que son
   <function>func_num_args</function>,
   <function>func_get_arg</function>, y
   <function>func_get_args</function> para más información.
  </simpara>
  <para>
   Es posible llamar a funciones recursivas en PHP.
   <example>
    <title>Funciones recursivas</title>
    <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Las llamadas de métodos/funciones recursivas con 100-200 grados de
     recursividad pueden llenar la pila y así, terminar el script actual.
     Tenga en cuenta que una recursión infinita es considerada como un error de
     programación.
    </simpara>
   </note>
  </para>

 </sect1>

 <sect1 xml:id="functions.arguments">
  <title>Parámetros y argumentos de función</title>
  <simpara>
   Los parámetros de la función son declarados en la firma de la función.
   La información puede ser pasada a
   una función utilizando una lista de argumentos, cada
   expresión separada por una coma. Los argumentos serán
   evaluados de izquierda a derecha, y el resultado es asignado a los parámetros de
   la función, antes de que la función sea efectivamente llamada
   (evaluación <emphasis>inmediata</emphasis>).
  </simpara>
  <!-- Note: this paragraph feels like it should be moved to the syntax part? -->
  <para>
   PHP soporta el paso de argumentos por valor (comportamiento por defecto), <link
   linkend="functions.arguments.by-reference">el paso por referencia</link>, y <link
   linkend="functions.arguments.default">valores de argumentos por defecto</link>.
   Una <link linkend="functions.variable-arg-list">lista variable de argumentos</link>,
   así como los <link linkend="functions.named-arguments">Argumentos Nominados</link>
   son también soportados.
  </para>
  <note>
   <para>
    A partir de PHP 7.3.0, es posible tener una coma final en la lista de argumentos
    para las llamadas de función:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$v = foo(
    $arg_1,
    $arg_2,
);
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </note>

   <para>
    A partir de PHP 8.0.0, la lista de argumentos de función puede incluir una
    coma final, que será ignorada. Esto es particularmente práctico en
    los casos donde la lista de argumentos es larga o contiene nombres de variables
    largos, haciéndolo práctico para listar los argumentos verticalmente.
   </para>
   <example>
    <title>Lista de parámetros de la función con una coma final</title>
    <programlisting role="php">
<![CDATA[
<?php
function takes_many_args(
    $first_arg,
    $second_arg,
    $a_very_long_argument_name,
    $arg_with_default = 5,
    $again = 'a default string', // Esta coma final no era permitida antes de 8.0.0.
)
{
    // ...
}
?>
]]>
    </programlisting>
   </example>

  <sect2 xml:id="functions.arguments.by-reference">
   <title>Paso de argumentos por referencia</title>

   <simpara>
    Por defecto, los argumentos son pasados
    a la función por valor (también, cambiar el valor de un argumento en la función no
    cambia su valor fuera de la función). Si se desea que las funciones
    puedan cambiar el valor de los argumentos, se deben pasar estos argumentos por referencia.
   </simpara>
   <para>
    Si se desea que un argumento sea siempre pasado
    por referencia, se puede añadir un '<literal>&amp;</literal>'
    antes del parámetro en la declaración de la función:
   </para>
   <para>
    <example>
     <title>Paso de argumentos de función por referencia</title>
     <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= ', y un poco más.';
}
$str = 'Esto es una cadena';
add_some_extra($str);
echo $str; // Muestra: 'Esto es una cadena, y un poco más.'
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    No es correcto pasar una expresión constante como argumento a un parámetro que espera ser pasado por referencia.
   </para>
  </sect2>

  <sect2 xml:id="functions.arguments.default">
   <title>Valores por defecto de los parámetros</title>

   <para>
    Una función puede definir valores por defecto para los parámetros utilizando una sintaxis similar
    a la asignación de una variable. El valor por defecto es utilizado únicamente cuando el argumento del parámetro no es
    pasado. Tenga en cuenta que pasar &null; no <emphasis>define</emphasis>
    el valor por defecto.
   </para>
   <para>
    <example>
     <title>Valor por defecto de los argumentos de funciones</title>
     <programlisting role="php">
<![CDATA[
<?php
function servir_cafe ($type = "cappuccino")
{
    return "Servir un $type.\n";
}
echo servir_cafe();
echo servir_cafe(null);
echo servir_cafe("espresso");
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Servir un cappuccino.
Servir un .
Servir un espresso.
]]>
     </screen>
    </example>
   </para>
   <para>
    Los valores por defecto de los parámetros pueden ser valores escalares,
    &array;s, el tipo especial &null;, y a partir de PHP 8.1.0,
    objetos utilizando la sintaxis <link linkend="language.oop5.basic.new">new ClassName()</link>.
   </para>
   <para>
    <example>
     <title>Uso de tipo no escalar como valor por defecto</title>
     <programlisting role="php">
<![CDATA[
<?php
function servir_cafe($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "las manos" : $coffeeMaker;
    return "Preparación de una taza de ".join(", ", $types)." con $device.\n";
}
echo servir_cafe();
echo servir_cafe(array("cappuccino", "lavazza"), "una cafetera");
?>
]]>
     </programlisting>
     &example.outputs;
      <screen>
<![CDATA[
Preparación de una taza de cappuccino con las manos.
Preparación de una taza de cappuccino, lavazza con una cafetera.
]]>
      </screen>
    </example>
   </para>
    <para>
      <example>
        <title>Uso de objetos como valores por defecto (a partir de PHP 8.1.0)</title>
        <programlisting role="php">
<![CDATA[
<?php
class DefaultCoffeeMaker {
    public function brew() {
        return 'Hacer café.\n';
    }
}
class FancyCoffeeMaker {
    public function brew() {
        return 'Crear un bonito café solo para usted.\n';
    }
}
function makecoffee($coffeeMaker = new DefaultCoffeeMaker)
{
    return $coffeeMaker->brew();
}
echo makecoffee();
echo makecoffee(new FancyCoffeeMaker);
?>
]]>
        </programlisting>

      &example.outputs;
      <screen>
<![CDATA[
Hacer café.
Crear un bonito café solo para usted.
]]>
      </screen>
      </example>
    </para>
   <simpara>
    El valor por defecto de un argumento debe
    obligatoriamente ser una constante, y no puede ser
    ni una variable, ni un miembro de clase, ni un llamado de función.
   </simpara>
   <para>
    Tenga en cuenta que todos los parámetros opcionales deben ser especificados después de los
    parámetros obligatorios, de lo contrario no pueden ser omitidos en las llamadas.
    Considere el siguiente código:
   </para>
   <para>
    <example>
     <title>Uso incorrecto de los parámetros de función por defecto</title>
     <programlisting role="php">
<![CDATA[
<?php
function hacerunyaourt ($container = "bol", $flavour)
{
    return "Preparar un $container de yaourt a la $flavour.\n";
}

echo hacerunyaourt("framboise");   // "framboise" es $container, no $flavour
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Fatal error: Uncaught ArgumentCountError: Too few arguments
 to function hacerunyaourt(), 1 passed in example.php on line 42
]]>
     </screen>
    </example>
   </para>
   <para>
    Ahora compare el ejemplo anterior con el siguiente ejemplo:
   </para>
   <para>
    <example>
     <title>Uso correcto de los parámetros de función por defecto</title>
     <programlisting role="php">
<![CDATA[
<?php
function hacerunyaourt ($flavour, $container = "bol")
{
    return "Preparar un $container de yaourt a la $flavour.\n";
}

echo hacerunyaourt ("framboise");   // "framboise" es $flavour
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Preparar un bol de yaourt a la framboise.
]]>
     </screen>
    </example>
   </para>
    <para>
      A partir de PHP 8.0.0, los <link linkend="functions.named-arguments">argumentos nombrados</link>
      pueden ser utilizados para pasar por alto varios parámetros opcionales.
    </para>
    <para>
     <example>
      <title>Uso correcto de los parámetros de función por defecto</title>
      <programlisting role="php">
<![CDATA[
<?php
function hacerunyaourt($container = "bol", $flavour = "framboise", $style = "Grec")
{
    return "Preparar un $container de yaourt $style a la $flavour.\n";
}
echo hacerunyaourt(style: "naturel");
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Preparar un bol de yaourt naturel a la framboise.
]]>
      </screen>
     </example>
    </para>
    <para>
      A partir de PHP 8.0.0, declarar parámetros obligatorios después de argumentos opcionales es <emphasis>obsoleto</emphasis>.
      Este problema puede generalmente ser resuelto abandonando el valor por defecto, ya que nunca será utilizado.
      Una excepción a esta regla concierne a los parámetros de la forma <code>Type $param = null</code>,
      donde el &null; por defecto hace el tipo implícitamente nullable.
      Este uso es deprecado desde PHP 8.4.0, y un
      <link linkend="language.types.declarations.nullable">tipo nullable</link>
      explícito debe ser utilizado en su lugar.
      <example>
       <title>Declaración de parámetros opcionales después de parámetros obligatorios</title>
        <programlisting role="php">
<![CDATA[
<?php

function foo($a = [], $b) {}     // Valor por defecto no utilizado; deprecado a partir de PHP 8.0.0
function foo($a, $b) {}          // Funcionalmente equivalente, sin advertencia de deprecación

function bar(A $a = null, $b) {} // A partir de PHP 8.1.0, $a es implícitamente requerido
                                 // (porque precede a un parámetro requerido),
                                 // pero implícitamente nullable (deprecado a partir de PHP 8.4.0),
                                 // porque el valor por defecto del parámetro es null
function bar(?A $a, $b) {}       // Recomendado

?>
]]>
        </programlisting>
      </example>
    </para>
    <note>
      <simpara>
        A partir de PHP 7.1.0, la omisión de un parámetro que no especifica un valor por defecto lanza
        un <classname>ArgumentCountError</classname>;
        en versiones anteriores, esto levantaba una advertencia.
      </simpara>
    </note>
   <note>
    <simpara>
     Los argumentos pasados por referencia pueden tener
     una valor por defecto.
    </simpara>
   </note>
  </sect2>

  <sect2 xml:id="functions.variable-arg-list">
   <title>Lista de argumentos de número variable</title>

   <simpara>
    PHP soporta los argumentos de número variable en las
    funciones definidas por el usuario utilizando el token
    <literal>...</literal>.
   </simpara>

   <para>
    La lista de argumentos puede incluir el
    token <literal>...</literal> para indicar que esta función acepta
    un número variable de argumentos. Los argumentos serán pasados en la variable
    proporcionada en forma de un &array;:

    <example>
     <title>Uso de <literal>...</literal> para acceder a los argumentos variables</title>
     <programlisting role="php">
<![CDATA[
<?php
function sum(...$numbers) {
    $acc = 0;
    foreach ($numbers as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
10
]]>
     </screen>
    </example>
   </para>

   <para>
    <literal>...</literal> puede también ser utilizado durante las llamadas de
    funciones para extraer el &array; o la variable
    <classname>Traversable</classname> o el literal en la lista de argumentos:

    <example>
     <title>Uso de <literal>...</literal> para proporcionar argumentos</title>
     <programlisting role="php">
<![CDATA[
<?php
function add($a, $b) {
    return $a + $b;
}

echo add(...[1, 2])."\n";

$a = [1, 2];
echo add(...$a);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
3
3
]]>
     </screen>
    </example>
   </para>

   <para>
    Se pueden especificar parámetros clásicos antes de la palabra clave
    <literal>...</literal>. En este caso, solo los argumentos finales
    que no corresponden a un argumento clásico serán añadidos
    al array generado por <literal>...</literal>.
   </para>

   <para>
    También es posible añadir una
    <link linkend="language.types.declarations">declaración de tipo</link>
    antes del token <literal>...</literal>. Si esto está presente,
    entonces todos los argumentos capturados por <literal>...</literal>
    deben corresponder al tipo de parámetro.

    <example>
     <title>Transtipado de argumentos variables</title>
     <programlisting role="php">
<![CDATA[
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' días';

// Esto fallará, porque null no es un objeto DateInterval.
echo total_intervals('d', null);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
3 días
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
]]>
     </screen>
    </example>
   </para>

   <para>
    Finalmente, se pueden pasar argumentos variables
    <link linkend="functions.arguments.by-reference">por referencia</link>
    prefijando la palabra clave <literal>...</literal> de un ET comercial
    (<literal>&amp;</literal>).
   </para>

  </sect2>

  <sect2 xml:id="functions.named-arguments">
   <title>Argumentos Nominados</title>

   <para>
    PHP 8.0.0 introduce los argumentos nombrados como extensión a los parámetros
    posicionales existentes. Los argumentos nombrados permiten pasar los
    argumentos a una función basándose en el nombre del parámetro, en lugar de
    la posición del parámetro. Esto documenta automáticamente el significado
    del argumento, hace el orden de los argumentos independiente y permite omitir
    los valores por defecto arbitrariamente.
   </para>

   <para>
    Los argumentos nombrados son pasados prefijando el valor con el nombre del
    parámetro seguido de dos puntos. Utilizar palabras clave reservadas como
    nombre de parámetro está permitido. El nombre del parámetro debe ser un identificador,
    especificarlo de manera dinámica no está permitido.
   </para>

   <example>
    <title>Sintaxis de los argumentos nombrados</title>
    <programlisting role="php">
<![CDATA[
<?php
myFunction(paramName: $value);
array_foobar(array: $value);

// NO soportado.
function_name($variableStoringParamName: $value);
?>
]]>
    </programlisting>
   </example>

   <example>
    <title>Argumentos posicionales comparados con argumentos nombrados</title>
    <programlisting role="php">
<![CDATA[
<?php
// Utilizando los argumentos posicionales:
array_fill(0, 100, 50);

// Utilizando los argumentos nombrados:
array_fill(start_index: 0, count: 100, value: 50);
?>
]]>
    </programlisting>
   </example>

   <para>
    El orden en el que los argumentos nombrados son pasados no importa.
   </para>

   <example>
    <title>Mismo ejemplo que el anterior, pero con un orden de parámetro diferente</title>
    <programlisting role="php">
<![CDATA[
<?php
array_fill(value: 50, count: 100, start_index: 0);
?>
]]>
    </programlisting>
   </example>

   <para>
    Los argumentos nombrados pueden ser combinados con los argumentos posicionales.
    En cuyo caso, los argumentos nombrados deben venir después de los argumentos posicionales.
    También es posible especificar solo algunos de los argumentos opcionales
    de una función, independientemente de su orden.
   </para>

   <example>
    <title>Combinar los argumentos nombrados con los argumentos posicionales</title>
    <programlisting role="php">
<![CDATA[
<?php
htmlspecialchars($string, double_encode: false);
// Same as
htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML401, 'UTF-8', false);
?>
]]>
    </programlisting>
   </example>

   <para>
    Pasar el mismo argumento varias veces resulta en una
    <classname>Error</classname> excepción.
   </para>

   <example>
    <title>Error lanzado cuando un argumento es pasado varias veces al mismo parámetro nombrado</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo($param) { ... }

foo(param: 1, param: 2);
// Error: Named parameter $param overwrites previous argument

foo(1, param: 2);
// Error: Named parameter $param overwrites previous argument

?>
]]>
    </programlisting>
   </example>

    <para>
      A partir de PHP 8.1.0, es posible utilizar argumentos nombrados después de haber descomprimido los argumentos.
      Un argumento nombrado <emphasis>no debe</emphasis> sobrescribir un argumento ya descomprimido.
    </para>

    <example>
      <title>Uso de argumentos nombrados después de la descompresión</title>
      <programlisting role="php">
<![CDATA[
<?php
function foo($a, $b, $c = 3, $d = 4) {
  return $a + $b + $c + $d;
}
var_dump(foo(...[1, 2], d: 40)); // 46
var_dump(foo(...['b' => 2, 'a' => 1], d: 40)); // 46
var_dump(foo(...[1, 2], b: 20)); // Error fatal. El parámetro nombrado $b sobrescribe el argumento anterior.
?>
]]>
      </programlisting>
    </example>

  </sect2>
 </sect1>

 <sect1 xml:id="functions.returning-values">
  <title>Los valores de retorno</title>

  <para>
   Los valores son devueltos utilizando una
   instrucción de retorno opcional. Todos los tipos de variables
   pueden ser devueltos, incluyendo arrays y objetos. Esto hace
   que la función termine su ejecución inmediatamente y pase
   el control a la línea llamante. Ver
   <function>return</function>
   para más información.
  </para>
  <note>
   <para>
    Si <function>return</function>
    es omitido, el valor &null; será devuelto.
   </para>
  </note>

  <sect2>
   <title>Uso de return</title>
   <para>
    <example>
     <title>Uso de <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function cuadrado($num)
{
    return $num * $num;
}
echo cuadrado(4); // Muestra '16'
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Una función no puede devolver varios valores al mismo tiempo, pero
    se puede obtener el mismo resultado devolviendo un array.
   </para>
   <para>
    <example>
     <title>Devolver un array de una función</title>
     <programlisting role="php">
<![CDATA[
<?php
function numero_pequeno()
{
    return [0, 1, 2];
}
// La descomposición de un array recogerá cada miembro del array individualmente
[$cero, $uno, $dos] = numero_pequeno();

// Anterior a PHP 7.1, la única alternativa equivalente es utilizando la estructura de lenguaje list()
list ($cero, $uno, $dos) = numero_pequeno();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Para devolver una referencia de una función, utilice
    el operador &amp; tanto en la declaración de la función como en
    la asignación del valor de retorno.
   </para>
   <para>
    <example>
     <title>Devolver una referencia de una función</title>
     <programlisting role="php">
<![CDATA[
<?php
function &devolver_referencia()
{
    return $uneref;
}

$newref =& devolver_referencia();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Para más información sobre las referencias, refiérase a <link
    linkend="language.references">la explicación sobre las referencias</link>.
   </simpara>
  </sect2>
 </sect1>

 <sect1 xml:id="functions.variable-functions">
  <title>Funciones variables</title>

  <para>
   PHP soporta el concepto de funciones variables.
   Esto significa que si el nombre de una variable es seguido de paréntesis,
   PHP buscará una función con el mismo nombre y tratará de ejecutarla.
   Esto puede servir, entre otros, para hacer funciones de retrollamada, tablas de funciones...
  </para>
  <para>
   Las funciones variables no pueden funcionar con los
   elementos de lenguaje como los
   <function>echo</function>, <function>print</function>,
   <function>unset</function>, <function>isset</function>,
   <function>empty</function>, <function>include</function>,
   <function>require</function> etc. Se debe utilizar su
   propia gestión de funciones para utilizar uno de estos elementos
   de lenguaje como funciones variables.
  </para>
  <para>
   <example>
    <title>Ejemplo de función variable</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "dentro de foo()<br />\n";
}

function bar($arg = '')
{
    echo "Dentro de bar(); el argumento era '$arg'.<br />\n";
}

// Esto es una función desviada de echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Llamada a foo()

$func = 'bar';
$func('test');  // Llamada a bar()

$func = 'echoit';
$func('test');  // Llamada a echoit()
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   También se puede llamar a los métodos de un objeto utilizando el sistema de
   funciones variables.
   <example>
    <title>Ejemplo de método variable</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Llama al método Bar()
    }

    function Bar()
    {
        echo "Es Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();  // Llama a $foo->Variable()

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Al llamar a métodos estáticos, la llamada de función es mejor que
   el operador de propiedad estática:
   <example>
    <title>Ejemplo de método variable con propiedades estáticas</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static $variable = 'propiedad estática';
    static function Variable()
    {
        echo 'Método Variable llamado';
    }
}

echo Foo::$variable; // Esto muestra 'propiedad estática'. Es necesario tener una $variable en el contexto.
$variable = "Variable";
Foo::$variable();  // Esto llama a $foo->Variable(), leyendo así la $variable desde el contexto.

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Llamadas complejas</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static function bar()
    {
        echo "bar\n";
    }
    function baz()
    {
        echo "baz\n";
    }
}

$func = array("Foo", "bar");
$func(); // Muestra "bar"
$func = array(new Foo, "baz");
$func(); // Muestra "baz"
$func = "Foo::bar";
$func(); // Muestra "bar"
]]>
    </programlisting>
   </example>
  </para>

  <sect2 role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><function>is_callable</function></member>
     <member><function>call_user_func</function></member>
     <member><function>function_exists</function></member>
     <member><link linkend="language.variables.variable">Las variables variable</link></member>
    </simplelist>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="functions.internal">
  <title>Funciones internas</title>

  <para>
   PHP dispone de numerosas funciones y estructuras estándar. También
   hay funciones que requieren extensiones específicas de PHP, sin
   las cuales se obtendrá el error fatal
   <literal>undefined function</literal>. Por ejemplo, para utilizar las
   funciones  <link linkend="ref.image">de imágenes</link>,
   tales como <function>imagecreatetruecolor</function>, se necesitará el
   soporte de <productname>GD</productname> en PHP. O bien, para utilizar
   <function>mysqli_connect</function>, se necesitará la extensión
   <link linkend="book.mysqli">MySQLi</link>. Hay funciones básicas que
   están incluidas en todas las versiones de PHP, tales como las funciones de
   <link linkend="ref.strings">cadenas de caracteres</link> y las funciones
   de <link linkend="ref.var">variables</link>. Utilice
   <function>phpinfo</function> o
   <function>get_loaded_extensions</function> para saber cuáles son las
   extensiones que están compiladas con su PHP. Tenga en cuenta también que
   muchas extensiones están activadas por defecto, y que el manual PHP está
   compartimentado por extensión. Vea los capítulos de
   <link linkend="configuration">configuración</link>,
   <link linkend="install">instalación</link> así como los
   detalles particulares a cada extensión, para saber cómo ponerlas en marcha.
  </para>
  <para>
   Leer y comprender el prototipo de una función se describe en el anexo
   <link linkend="about.prototypes">Cómo leer la definición de una
    función (prototipo)</link>.
   Es importante comprender qué devuelve una función, o si una
   función trabaja directamente sobre el valor de los parámetros proporcionados. Por
   ejemplo, <function>str_replace</function> devolverá una cadena modificada,
   mientras que <function>usort</function> trabaja directamente sobre la variable
   pasada en parámetro. Cada página del manual tiene información específica
   sobre cada función, como el número de parámetros, las evoluciones de
   especificaciones, los valores devueltos en caso de éxito o fracaso, y la
   disponibilidad en función de las versiones. Conocer bien estas diferencias,
   a veces sutiles, es crucial para programar bien en PHP.
  </para>
  <note>
   <simpara>
    Si los parámetros dados a una función no son correctos, como el hecho
    de pasar un &array; cuando se espera una &string;, el valor devuelto
    de la función es indefinido. En este caso, la función devolverá la mayoría
    de las veces un valor &null; pero esto es solo una convención y
    no puede ser considerado como una certeza.
    A partir de PHP 8.0.0, una excepción <classname>TypeError</classname>
    es normalmente lanzada en este caso.
   </simpara>
  </note>
  <note>
   <para>
    En modo coercitivo, los tipos escalares de las funciones internas son nullables por defecto.
    A partir de PHP 8.1.0, pasar &null; a un parámetro de función interna que no está declarado
    nullable es desaconsejado y emite una notificación de deprecación en modo coercitivo para alinearse
    con el comportamiento de las funciones definidas por el usuario, donde los tipos escalares deben
    ser marcados como nullables explícitamente.
   </para>
   <para>
    Por ejemplo, la función <function>strlen</function> espera que el parámetro <literal>$string</literal>
    sea de tipo &string; y no &null;.
    Por razones históricas, PHP permite el paso de &null; para este parámetro en modo coercitivo.
    El parámetro es entonces implícitamente convertido en <type>string</type>, resultando en un valor <literal>""</literal>.
    Tenga en cuenta que se emite una <classname>TypeError</classname> en modo estricto.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(strlen(null));
// "Deprecated: Passing null to parameter #1 ($string) of type string is deprecated" as of PHP 8.1.0
// int(0)

var_dump(str_contains("foobar", null));
// "Deprecated: Passing null to parameter #2 ($needle) of type string is deprecated" as of PHP 8.1.0
// bool(true)
?>
]]>
     </programlisting>
    </informalexample>
   </note>
  <sect2 role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><function>function_exists</function></member>
     <member><link linkend="funcref">el índice de funciones</link></member>
     <member><function>get_extension_funcs</function></member>
     <member><function>dl</function></member>
    </simplelist>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="functions.anonymous">
  <title>Funciones anónimas</title>
  <simpara>
   Las funciones anónimas, también llamadas cierres o <literal>closures</literal>
   permiten la creación de funciones sin especificar su nombre.
   Son particularmente útiles como funciones de retrollamada <type>callable</type>,
   pero su uso no se limita a este solo uso.
  </simpara>
  <simpara>
   Las funciones anónimas se implementan utilizando la clase
   <link linkend="class.closure"><classname>Closure</classname></link>.
  </simpara>

  <example>
   <title>Ejemplos con funciones anónimas</title>
   <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hola-mundo');
?>
]]>
   </programlisting>
  </example>

  <simpara>
   Las funciones anónimas también pueden ser utilizadas como valores de
   variables. PHP convertirá automáticamente estas expresiones
   en objetos <classname>Closure</classname>. Asignar un cierre
   a una variable es lo mismo que una asignación clásica,
   incluyendo el punto y coma final.
  </simpara>

  <example>
   <title>Asignación de función anónima a una variable</title>
   <programlisting role="php">
<![CDATA[
<?php
$saludo = function($nombre) {
    printf("Hola %s\r\n", $nombre);
};

$saludo('Mundo');
$saludo('PHP');
?>
]]>
   </programlisting>
  </example>

  <simpara>
   Las funciones anónimas pueden heredar variables del contexto de su
   padre. Estas variables deben entonces ser pasadas en la construcción
   de lenguaje <literal>use</literal>.
   A partir de PHP 7.1, estas variables no deben incluir &link.superglobals;,
   <varname>$this</varname>, o variables con el mismo nombre que un parámetro.
   Una declaración de tipo de retorno para la función debe ser colocada
   <emphasis>después</emphasis> de la cláusula <literal>use</literal>.
  </simpara>

  <example>
   <title>Herencia de variable desde el contexto padre</title>
   <programlisting role="php">
<![CDATA[
<?php
$mensaje = 'hola';

// Sin "use"
$ejemplo = function () {
    var_dump($mensaje);
};
$ejemplo();

// Hereda $mensaje
$ejemplo = function () use ($mensaje) {
    var_dump($mensaje);
};
$ejemplo();

// El valor de la variable heredada se define cuando la función es
// definida no cuando es llamada
$mensaje = 'mundo';
$ejemplo();

// Reasignación de la variable mensaje
$mensaje = 'hola';

// Herencia por referencia
$ejemplo = function () use (&$mensaje) {
    var_dump($mensaje);
};
$ejemplo();

// El cambio de valor en el contexto padre es reflejado al
// llamar a la función.
$mensaje = 'mundo';
$ejemplo();

// Las funciones anónimas también aceptan argumentos clásicos
$ejemplo = function ($arg) use ($mensaje) {
    var_dump($arg . ' ' . $mensaje);
};
$ejemplo("hola");

// La declaración de tipo de retorno viene después de la cláusula use
$ejemplo = function () use ($mensaje): string {
    return "hola $mensaje";
};
var_dump($ejemplo());
?>
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Notice: Undefined variable: mensaje in /example.php on line 6
NULL
string(5) "hola"
string(5) "hola"
string(5) "hola"
string(5) "mundo"
string(11) "hola mundo"
string(11) "hola mundo"
]]>
   </screen>
  </example>

  <para>
   A partir de PHP 8.0.0, la lista de variables heredadas del contexto puede
   incluir una coma final, que será ignorada.
  </para>
  <simpara>
   La herencia del contexto padre
   <emphasis>no es</emphasis> lo mismo que las variables
   del entorno global. Las variables globales existen en el
   contexto global, que es el mismo, independientemente de la función que
   se ejecute. El contexto padre de una función anónima es la función
   en la que la función fue declarada (no necesariamente la que llama). Vea el
   ejemplo a continuación:
  </simpara>

  <example>
   <title>Funciones anónimas y contexto</title>
   <programlisting role="php">
<![CDATA[
<?php
// Un carrito de compra simple, que contiene una lista de productos
// elegidos y la cantidad deseada de cada producto. Incluye
// un método que calcula el precio total de los elementos en el carrito
// utilizando una función de retrollamada anónima.
class Carrito
{
    const PRECIO_MANTEQUILLA  = 1.00;
    const PRECIO_LECHE    = 3.00;
    const PRECIO_HUEVO    = 6.95;

    protected $productos = array();

    public function add($producto, $cantidad)
    {
        $this->productos[$producto] = $cantidad;
    }

    public function getCantidad($producto)
    {
        return isset($this->productos[$producto]) ? $this->productos[$producto] :
               FALSE;
    }

    public function getTotal($impuesto)
    {
        $total = 0.00;

        $callback =
            function ($cantidad, $producto) use ($impuesto, &$total)
            {
                $precioPorArticulo = constant(__CLASS__ . "::PRECIO_" .
                    strtoupper($producto));
                $total += ($precioPorArticulo * $cantidad) * ($impuesto + 1.0);
            };

        array_walk($this->productos, $callback);
        return round($total, 2);
    }
}

$mi_carrito = new Carrito;

// Añadir elementos al carrito
$mi_carrito->add('mantequilla', 1);
$mi_carrito->add('leche', 3);
$mi_carrito->add('huevo', 6);

// Mostrar el precio con 5.5% de IVA
print $mi_carrito->getTotal(0.055) . "\n";
// El resultado será 54.29
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>Enlace automático de <literal>$this</literal></title>
   <programlisting role="php">
<![CDATA[
<?php

class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$objeto = new Test;
$funcion = $objeto->testing();
$funcion();

?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
object(Test)#1 (0) {
}
]]>
    </screen>
  </example>

  <para>
   Cuando se declara en el contexto de una clase, la clase
   actual es automáticamente enlazada, haciéndola <literal>$this</literal>
   disponible en el contexto de la función. Si este enlace automático de
   la clase actual no es deseado, entonces las
   <link linkend="functions.anonymous-functions.static">funciones anónimas
    estáticas</link> pueden ser utilizadas en su lugar.
  </para>

  <sect2 xml:id="functions.anonymous-functions.static">
   <title>Las funciones anónimas estáticas</title>
   <para>
    Las funciones anónimas pueden ser declaradas estáticamente.
    Esto permite no enlazar automáticamente la clase actual a la función.
    Los objetos también pueden no ser enlazados durante la ejecución.
   </para>
   <para>
    <example>
     <title>Intento de uso de <literal>$this</literal> en una función anónima estática</title>
     <programlisting role="php">
<![CDATA[
<?php

class Foo
{
    function __construct()
    {
        $func = static function() {
            var_dump($this);
        };
        $func();
    }
};
new Foo();

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Notice: Undefined variable: this in %s on line %d
NULL
]]>
      </screen>
     </example>
    </para>

    <para>
     <example>
      <title>Intento de enlace de un objeto a una función anónima estática</title>
      <programlisting role="php">
<![CDATA[
<?php

$func = static function() {
    // cuerpo de la función
};
$func = $func->bindTo(new stdClass);
$func();

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Cannot bind an instance to a static closure in %s on line %d
]]>
      </screen>
     </example>
    </para>
  </sect2>

  <sect2 role="changelog">
   &reftitle.changelog;
   <para>
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>8.3.0</entry>
        <entry>
         Los cierres creados a partir de los <link linkend="language.oop5.magic">métodos
         mágicos</link> pueden aceptar parámetros nombrados.
        </entry>
       </row>
       <row>
        <entry>7.1.0</entry>
        <entry>
         Las funciones anónimas pueden no cerrarse sobre las &link.superglobals;,
         <varname>$this</varname>, o cualquier variable con el mismo nombre que un
         parámetro.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>

  <sect2 role="notes">
   &reftitle.notes;
   <note>
    <simpara>
     Es posible utilizar las funciones <function>func_num_args</function>,
     <function>func_get_arg</function> y <function>func_get_args</function>
     en una función anónima.
    </simpara>
   </note>
  </sect2>
  </sect1>

  <sect1 xml:id="functions.arrow">
   <title>Función Flecha</title>

   <simpara>
    Las funciones flecha fueron introducidas en PHP 7.4 como una sintaxis
    más concisa para las
    <link linkend="functions.anonymous">funciones anónimas</link>.
   </simpara>
   <simpara>
    Las funciones anónimas como las funciones flecha son implementadas utilizando la clase
    <link linkend="class.closure"><classname>Closure</classname></link>.
   </simpara>

   <simpara>
    Las funciones flecha tienen la forma básica
    <code>fn (argument_list) =&gt; expr</code>.
   </simpara>

   <simpara>
    Las funciones flecha soportan las mismas funcionalidades que las
    <link linkend="functions.anonymous">funciones anónimas</link>,
    a excepción de que el uso de las variables del ámbito padre es
    automático.
   </simpara>

   <simpara>
    Cuando una variable utilizada en la expresión es definida en el ámbito
    padre, será implícitamente capturada por valor.
    En el siguiente ejemplo, las funciones <varname>$fn1</varname> y
    <varname>$fn2</varname> se comportan de manera idéntica.
   </simpara>

   <para>
    <example>
     <title>Las funciones flecha capturan las variables por valor automáticamente</title>
     <programlisting role="php">
<![CDATA[
<?php

$y = 1;

$fn1 = fn($x) => $x + $y;
// equivalente a usar $y por valor:
$fn2 = function ($x) use ($y) {
    return $x + $y;
};

var_export($fn1(3));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
4
]]>
      </screen>
    </example>
   </para>
   <simpara>
    Esto también funciona si las funciones flecha están anidadas:
   </simpara>
   <para>
    <example>
     <title>Las funciones flecha capturan las variables por valor automáticamente, incluso anidadas</title>
     <programlisting role="php">
<![CDATA[
<?php

$z = 1;
$fn = fn($x) => fn($y) => $x * $y + $z;
// Muestra 51
var_export($fn(5)(10));
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    De manera similar a las funciones anónimas,
    la sintaxis de las funciones flecha permite firmas de función arbitrarias,
    esto incluye los tipos de parámetros y de retorno, valores por defecto, variables,
    así como el paso y retorno por referencia.
    Todos los siguientes ejemplos son funciones flecha válidas:
   </simpara>
   <para>
    <example>
     <title>Ejemplos de funciones flecha</title>
     <programlisting role="php">
<![CDATA[
<?php

fn(array $x) => $x;
static fn($x): int => $x;
fn($x = 42) => $x;
fn(&$x) => $x;
fn&($x) => $x;
fn($x, ...$rest) => $rest;

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Las funciones flecha enlazan las variables por valor.
    Esto es aproximadamente equivalente a realizar un <code>use($x)</code> para
    cada variable <varname>$x</varname> utilizada dentro de la función
    flecha.
    Un enlace por valor significa que no es posible modificar un
    valor del ámbito exterior.
    <link linkend="functions.anonymous">Las funciones anónimas</link>
    pueden ser utilizadas en su lugar para enlaces por referencia.
   </simpara>
   <para>
    <example>
     <title>
      Los valores del ámbito exterior no pueden ser modificados por las funciones flecha
     </title>
     <programlisting role="php">
<![CDATA[
<?php

$x = 1;
$fn = fn() => $x++; // No tiene efecto
$fn();
var_export($x);  // Muestra 1

?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 role="changelog">
   &reftitle.changelog;
   <para>
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>7.4.0</entry>
        <entry>
         Las funciones flecha están ahora disponibles.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
   </sect2>

   <sect2 role="notes">
   &reftitle.notes;
   <note>
    <simpara>
     Es posible utilizar <function>func_num_args</function>,
     <function>func_get_arg</function>, y <function>func_get_args</function>
     desde el interior de una función flecha.
    </simpara>
   </note>
   </sect2>
  </sect1>

 <sect1 xml:id="functions.first_class_callable_syntax">
  <title>Sintaxis callable de primera clase</title>

  <para>
   La sintaxis de callable de primera clase es introducida a partir de PHP 8.1.0,
   como una manera de crear <link linkend="functions.anonymous">funciones anónimas</link>
   a partir de <link linkend="language.types.callable">callable</link>.
   Reemplaza la sintaxis de callables existente utilizando cadenas y arrays.
   La ventaja de esta sintaxis es que es accesible al análisis estático
   y utiliza el ámbito del punto donde el callable es adquirido.
  </para>

  <para>
   La sintaxis <code>CallableExpr(...)</code> es utilizada para crear un objeto
   <classname>Closure</classname> a partir del callable.
   <code>CallableExpr</code> acepta cualquier expresión que pueda ser directamente
   llamada en la gramática de PHP:
   <example>
    <title>Sintaxis callable de primera clase básica</title>
    <programlisting role="php">
     <![CDATA[
<?php
class Foo {
   public function method() {}
   public static function staticmethod() {}
   public function __invoke() {}
}
$obj = new Foo();
$classStr = 'Foo';
$methodStr = 'method';
$staticmethodStr = 'staticmethod';
$f1 = strlen(...);
$f2 = $obj(...);  // invokable object
$f3 = $obj->method(...);
$f4 = $obj->$methodStr(...);
$f5 = Foo::staticmethod(...);
$f6 = $classStr::$staticmethodStr(...);
// traditional callable using string, array
$f7 = 'strlen'(...);
$f8 = [$obj, 'method'](...);
$f9 = [Foo::class, 'staticmethod'](...);
?>
]]>
    </programlisting>
   </example>
  </para>

  <note>
   <para>
    Los <code>...</code> forman parte de la sintaxis y no son una omisión.
   </para>
  </note>

  <para>
   <code>CallableExpr(...)</code> tiene las mismas semánticas que <methodname>Closure::fromCallable</methodname>.
   Es decir, a diferencia de los callables utilizando cadenas y arrays,
   <code>CallableExpr(...)</code> respeta el ámbito del punto donde es creado:
   <example>
    <title>Comparación de ámbito de <code>CallableExpr(...)</code> y de callables tradicionales</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo {
    public function getPrivateMethod() {
        return [$this, 'privateMethod'];
    }
    private function privateMethod() {
        echo __METHOD__, "\n";
    }
}
$foo = new Foo;
$privateMethod = $foo->getPrivateMethod();
$privateMethod();
// Fatal error: Call to private method Foo::privateMethod() from global scope
// This is because call is performed outside from Foo and visibility will be checked from this point.
class Foo1 {
    public function getPrivateMethod() {
        // Uses the scope where the callable is acquired.
        return $this->privateMethod(...); // identical to Closure::fromCallable([$this, 'privateMethod']);
    }
    private function privateMethod() {
        echo __METHOD__, "\n";
    }
}
$foo1 = new Foo1;
$privateMethod = $foo1->getPrivateMethod();
$privateMethod();  // Foo1::privateMethod
?>
]]>
    </programlisting>
   </example>

  </para>

  <note>
   <para>
    La creación de objetos con esta sintaxis (e.g <code>new Foo(...)</code>) no es soportada,
    porque la sintaxis <code>new Foo()</code> no es considerada como una llamada.
   </para>
  </note>

  <note>
   <para>
    La sintaxis de callable de primera clase no puede ser combinada con
    el <link linkend="language.oop5.basic.nullsafe">operador nullsafe</link>.
    Los dos casos siguientes resultan en un error de compilación:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$obj?->method(...);
$obj?->prop->method(...);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </note>
 </sect1>

</chapter>
